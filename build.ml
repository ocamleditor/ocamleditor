(**

  This file is automatically generated by OCamlEditor. Do not edit.

*)

#directory "+threads" #load "str.cma" #load "unix.cma" #load "threads.cma"
let split re = Str.split (Str.regexp re)
module Argc = struct type command_descr = string type command_usage = string type speclist = (Arg.key * Arg.spec * Arg.doc) list module type COMMAND = sig type t val string_of_command : t -> string val command_of_string : string -> t val options : (t * speclist * command_descr * command_usage) list val anon_fun : t -> string -> unit end module Make (C : COMMAND) = struct open Printf exception Command_found exception Help_Command of C.t * (speclist * command_descr * command_usage) * string let command : C.t option ref = ref None;; let commands, cmd_map = List.fold_left (fun (x, y) (a, b, c, d) -> a::x, (a, (b, c, d))::y) ([], []) C.options let rpad txt c width = let result = txt ^ (String.make width c) in String.sub result 0 width;; let help_of_commands = let help_of_command maxlength cmd = let _ , descr, _ = List.assoc cmd cmd_map in (sprintf "  %s  %s" (rpad (C.string_of_command cmd) ' ' maxlength) descr) in let maxlength = List.fold_left (fun cand x -> max cand (String.length (C.string_of_command x))) 0 commands in "\n" ^ (String.concat "\n" (List.map (help_of_command maxlength) (List.rev commands))) let create_help_msg global_speclist usage_msg = sprintf "%s\n\nGLOBAL OPTIONS%s\nCOMMANDS%s\n" usage_msg (Arg.usage_string global_speclist "") help_of_commands;; let with_command f = match !command with Some cmd -> f cmd | _ -> assert false;; let parse_argv args ~(global_options : speclist) ?default_command ?(usage_msg=sprintf "\nUSAGE\n  %s [global_options*] <command> [options*] [args*]\n  %s <command> --help" (Filename.basename args.(0)) (Filename.basename args.(0))) execute_command = command := None; Arg.current := 0; let parse_anon arg = match !command with | None -> let cmd = try C.command_of_string arg with ex -> decr Arg.current; (match default_command with Some c -> c | _ -> raise ex) in command := Some cmd; raise Command_found | _ -> assert false in let help_string () = match !command with | Some cmd -> let spec, descr, _ = List.assoc cmd cmd_map in let cmd = C.string_of_command cmd in Arg.usage_string spec (sprintf "%s %s - %s\n\nUSAGE\n  %s [global_options*] %s [options*] [args*]\n\nOPTIONS" (Filename.basename args.(0)) cmd descr (Filename.basename args.(0)) cmd) | _ -> create_help_msg global_options usage_msg in if Array.length args = 1 then (raise (Arg.Help (help_string()))); try Arg.parse_argv args global_options parse_anon usage_msg; with | Command_found -> let len = Array.length args - !Arg.current in let command_args = Array.make len "" in Array.blit args !Arg.current command_args 0 len; let parse_anon = with_command (fun cmd -> C.anon_fun cmd) in begin try Arg.current := 0; let speclist = with_command (fun cmd -> let sp, _, _ = try List.assoc cmd cmd_map with Not_found -> assert false in sp) in Arg.parse_argv command_args speclist parse_anon usage_msg; let f = function | Some cmd -> execute_command cmd | None -> raise (Arg.Help (create_help_msg global_options usage_msg)) in f !command with | Arg.Help _ -> with_command begin fun cmd -> let cmd_specs, cmd_descr, cmd_usage = List.assoc cmd cmd_map in raise (Help_Command  (cmd, (cmd_specs, cmd_descr, cmd_usage), help_string ())) end | Arg.Bad msg as ex -> with_command begin fun _cmd -> try let first_line = String.sub msg 0 (String.index msg '\n') in raise (Arg.Bad (sprintf "%s\n%s" first_line (help_string()))) with Not_found -> raise ex end end; | Arg.Bad _ -> raise (Arg.Bad (sprintf "unknown global option `%s'\n%s" (args.(!Arg.current)) (help_string()))) | Arg.Help _ -> raise (Arg.Help (help_string()));; let parse ~global_options ?default_command ?usage_msg f = parse_argv Sys.argv ~global_options ?default_command ?usage_msg f;; end;; end
module Shell = struct let redirect_stderr = if Sys.win32 then " 2>NUL" else " 2>/dev/null"  let get_command_output command = let ch = Unix.open_process_in command in set_binary_mode_in ch false; let output = ref [] in try while true do output := (input_line ch) :: !output done; assert false with End_of_file -> begin ignore (Unix.close_process_in ch); List.rev !output end | e -> begin ignore (Unix.close_process_in ch); raise e end  let quote_path = if Sys.os_type = "Win32" then (fun x -> Filename.quote (Filename.quote x)) else (fun x -> x)  let quote_arg = if Sys.os_type = "Win32" then (fun x -> Filename.quote x) else (fun x -> x) type state = StartArg | InUnquotedArg | InQuotedArg | InQuotedArgAfterQuote;; let format_args = String.concat " ";; let parse_args line = let args = ref [] in let buf = Buffer.create 10 in let state = ref StartArg in let start_arg () = state := StartArg; args := (Buffer.contents buf) :: !args; Buffer.clear buf; in String.iter begin function | (' ' as ch) when !state = InQuotedArg -> Buffer.add_char buf ch | ' ' when !state = StartArg -> () | ' ' when !state = InUnquotedArg -> start_arg (); | ' ' -> start_arg () | ('"' as ch) when !state = StartArg -> state := InQuotedArg; Buffer.add_char buf ch | ('"' as ch) when !state = InQuotedArg -> Buffer.add_char buf ch; start_arg (); | ('"' as ch) when !state = InQuotedArgAfterQuote -> Buffer.add_char buf ch; state := InQuotedArg; | ('"' as ch) when !state = InUnquotedArg -> start_arg (); Buffer.add_char buf ch; state := InQuotedArg; | ('\\' as ch) when !state = InQuotedArg -> state := InQuotedArgAfterQuote; Buffer.add_char buf ch | ch when !state = InQuotedArgAfterQuote -> state := InQuotedArg; Buffer.add_char buf ch; | ch when !state = StartArg -> state := InUnquotedArg; Buffer.add_char buf ch; | ch -> Buffer.add_char buf ch; end line; if Buffer.length buf > 0 then (start_arg ()); List.rev !args;;  end
module Ocaml_config = struct open Printf let redirect_stderr = if Sys.os_type = "Win32" then " 2>NUL" else " 2>/dev/null" let read_ocaml_config () = let conf = Printf.kprintf Shell.get_command_output "ocamlc -config" in let re = Str.regexp ": " in List.map (fun l -> match Str.split re l with [n;v] -> n, v | [n] -> n, "" | _ -> assert false) conf let cache = read_ocaml_config() let get name = List.assoc name cache let is_mingw = try get "system" = "mingw" with Not_found -> false let putenv_ocamllib value = match Sys.os_type with | "Win32" -> let value = match value with None -> "" | Some x -> x in Unix.putenv "OCAMLLIB" value | _ -> ignore (Sys.command "unset OCAMLLIB") let find_best_compiler compilers = try Some (List.find begin fun comp -> try let output = kprintf Shell.get_command_output "%s -version%s" comp redirect_stderr in output <> [] with _ -> false end compilers) with Not_found -> None;; let find_tool which path = let commands = match which with | `BEST_OCAMLC -> ["ocamlc.opt"; "ocamlc"] | `BEST_OCAMLOPT -> ["ocamlopt.opt"; "ocamlopt"] | `BEST_OCAMLDEP -> ["ocamldep.opt"; "ocamldep"] | `BEST_OCAMLDOC -> ["ocamldoc.opt"; "ocamldoc"] | `OCAMLC -> ["ocamlc"] | `OCAML -> ["ocaml"] in let commands = if Sys.win32 then List.map (fun c -> if Filename.check_suffix c ".opt" then c ^ ".exe" else c) commands else commands in let quote    = if path <> "" && Sys.os_type = "Win32" && String.contains path ' ' then Filename.quote else (fun x -> x) in let path     = if path <> "" then Filename.concat path "bin" else "" in find_best_compiler (List.map quote (List.map (Filename.concat path) commands)) let get_home () = try Sys.getenv "OCAML_HOME" with Not_found -> "" let expand_includes = let split = Str.split (Str.regexp " +") in fun compact -> if String.length compact > 0 then ("-I " ^ (String.concat " -I " (split compact))) else ""  let ocamlc ()   = match find_tool `BEST_OCAMLC (get_home ()) with Some x -> x | _ -> failwith "Cannot find 'ocamlc'" let ocamlopt () = find_tool `BEST_OCAMLOPT (get_home ()) let ocamldep () = match find_tool `BEST_OCAMLDEP (get_home ()) with Some x -> x | _ -> failwith "Cannot find 'ocamldep'" let ocamldoc () = match find_tool `BEST_OCAMLDOC (get_home ()) with Some x -> x | _ -> failwith "Cannot find 'ocamldoc'" let ocaml ()    = match find_tool `OCAML (get_home ()) with Some x -> x | _ -> failwith "Cannot find 'ocaml'" let ocamllib () = match Shell.get_command_output ((ocamlc()) ^ " -where") with x :: _ -> x | _ -> "" let ocaml_noinit () = ocaml () ^ " -noinit"  let ocaml_version ?(compiler=ocamlc()) () = String.concat "\n" (Shell.get_command_output (compiler ^ " -v " ^ redirect_stderr))  let can_compile_native ?ocaml_home () = let result = ref false in let filename = Filename.temp_file "test_native" ".ml" in let ochan = open_out filename in begin try output_string ochan ("0"); close_out ochan with _ -> (close_out ochan) end; let outname = Filename.chop_extension filename in let exename = outname ^ (if Sys.os_type = "Win32" then ".exe" else "") in let compiler = match ocaml_home with | Some home -> find_tool `BEST_OCAMLOPT home | _ -> Some "ocamlopt" in match compiler with | Some compiler -> let cmd = sprintf "%s -o %s %s%s" compiler exename filename (                                                              "") in result := (Sys.command cmd) = 0; if Sys.file_exists filename then (Sys.remove filename); if Sys.file_exists exename then (Sys.remove exename); let cmi = outname ^ ".cmi" in if Sys.file_exists cmi then (Sys.remove cmi); let cmx = outname ^ ".cmx" in if Sys.file_exists cmx then (Sys.remove cmx); let obj = outname ^ ".o" in if Sys.file_exists obj then (Sys.remove obj); let obj = outname ^ ".obj" in if Sys.file_exists obj then (Sys.remove obj); if Sys.win32 then begin let manifest = exename ^ ".manifest" in if Sys.file_exists manifest then (Sys.remove manifest); end; if !result then begin let conf = String.concat "\n" (kprintf Shell.get_command_output "%s -config" compiler) in let re = Str.regexp "ccomp_type: \\(.*\\)\n" in if Str.search_forward re conf 0 >= 0 then begin Some (Str.matched_group 1 conf) end else Some "<unknown ccomp_type>" end else None; | _ -> None ;; end
module App_config = struct open Printf let (//) = Filename.concat let (!!) = Filename.dirname let split sep str = let str = if str.[0] = sep then String.sub str 1 (String.length str - 1) else str in let str = if str.[(String.length str - 1)] = sep then String.sub str 0 (String.length str - 1) else str in let parts = ref [] in let i = ref (String.length str) in let j = ref !i in let str = ref str in while !i > 0 do decr i; if !str.[!i] = sep then begin parts := (String.sub !str (!i + 1) (!j - !i - 1)) :: !parts; str := String.sub !str 0 !i; j := !i; end else if !i = 0 then begin parts := (String.sub !str 0 !j) :: !parts; end done; !parts;;  let application_param = try List.fold_left begin fun acc x -> match                                split '=' x with | n :: v :: [] -> (n, v) :: acc | n :: [] -> (n, "") :: acc | _ -> acc end [] (                                split ',' (Sys.getenv "OCAMLEDITORPARAM")) with Not_found -> [];; let application_debug = try (List.assoc "debug" application_param) = "2" with Not_found -> false;;  let user_home = try Sys.getenv "HOME" with Not_found -> (try (Sys.getenv "HOMEDRIVE") // (Sys.getenv "HOMEPATH") with Not_found -> failwith "Please set your HOME environment variable.") let ocamleditor_user_home = let dirname = match Ocaml_config.is_mingw with | true when application_debug -> ".ocamleditor.mingw" | true -> ".ocamleditor.test.mingw" | false when application_debug -> ".ocamleditor.test" | false -> ".ocamleditor" in let ocamleditor_user_home = user_home // dirname in if not (Sys.file_exists ocamleditor_user_home) then (Unix.mkdir ocamleditor_user_home 509); ocamleditor_user_home let launcher_filename = ocamleditor_user_home // "launcher.list" let get_application_dir name = let is_app_in_cwd = !! Sys.executable_name = "." in let prefix = if is_app_in_cwd then Filename.dirname (Sys.getcwd()) else !! (!! Sys.executable_name) in let path = prefix // name in if Sys.file_exists path && (Sys.is_directory path) then path else let install_path = prefix // "share" // "ocamleditor" // name in install_path let application_icons = get_application_dir "icons" let application_plugins = get_application_dir "plugins" let get_oebuild_command = let find_best ?(param="--help") prog = let redirect_stderr = if Sys.os_type = "Win32" then " 2>NUL" else " 2>/dev/null" in try List.find begin fun comp -> let ok = try let cmd = sprintf "%s %s%s" (Filename.quote comp) param redirect_stderr in if application_debug then (printf "Checking for %s... %!" cmd); Shell.get_command_output cmd |> ignore; true with _ -> false in if application_debug then (printf "%b\n%!" ok); ok end prog with Not_found -> kprintf failwith "Cannot find: %s" (String.concat ", " prog) in let find_command name = let basename = name ^ (if Sys.win32 then ".exe" else "") in let path = (!! Sys.executable_name) // basename in if Sys.file_exists path && not (Sys.is_directory path) then path else let path = (!! Sys.executable_name) // (if Filename.check_suffix name ".opt" then Filename.chop_extension name else name) // basename in if Sys.file_exists path then path else basename in begin fun () -> let commands = [ find_command "oebuild.opt"; find_command "oebuild"; ] in find_best commands end end
module Spawn = struct type process = { pid : int; inchan : in_channel; outchan : out_channel; errchan : in_channel; } type result = [ `PID of int | `ERROR of exn | `SUCCESS ]  let create_process ?wd ?env program args = let (in_read, in_write) = Unix.pipe() in let (out_read, out_write) = Unix.pipe() in let (err_read, err_write) = Unix.pipe() in let inchan = Unix.in_channel_of_descr in_read in let outchan = Unix.out_channel_of_descr out_write in let errchan = Unix.in_channel_of_descr err_read in let cwd = ref None in begin match wd with | None -> () | Some x -> cwd := Some (Sys.getcwd()); Sys.chdir x end; let args = Array.of_list (List.filter (fun x -> String.trim x <> "") (Array.to_list args)) in  let args = Array.append [| program |] args in try let pid = match env with | None -> Unix.create_process program args out_read in_write err_write | Some env -> Unix.create_process_env program args env out_read in_write err_write in (match !cwd with None -> () | Some x -> Sys.chdir x; cwd := None); Unix.close out_read; Unix.close in_write; Unix.close err_write; let proc = { pid; inchan; outchan; errchan } in proc with | Unix.Unix_error (err, a, b) as ex -> (match !cwd with None -> () | Some x -> Sys.chdir x; cwd := None);  raise ex | ex -> (match !cwd with None -> () | Some x -> Sys.chdir x; cwd := None); raise ex  let loop (f : in_channel -> unit) chan = try while true do f chan done with End_of_file -> ()  let redirect_to_stdout = loop (fun chan -> input_line chan |> print_endline)  let redirect_to_stderr = loop (fun chan -> input_line chan |> prerr_endline)  let redirect_to_ignore = loop (fun chan -> input_line chan |> ignore)  let exec mode ?working_directory ?env ?at_exit ?process_in ?process_out ?process_err ?(binary=false) program args = try let proc = create_process ?wd:working_directory ?env program args in set_binary_mode_in proc.inchan binary; set_binary_mode_in proc.errchan binary; set_binary_mode_out proc.outchan binary; let process_in = match process_in with Some f -> f | _ -> redirect_to_ignore in let process_err = match process_err with Some f -> f | _ -> redirect_to_ignore in let final () = let f = match at_exit with Some f -> f | _ -> ignore in try Stdlib.close_in proc.inchan; Stdlib.close_in proc.errchan; Stdlib.close_out proc.outchan; f None with (Unix.Unix_error _) as ex -> f (Some ex) in let tho = match process_out with Some f -> Some (Thread.create f proc.outchan) | _ -> None in let thi = Thread.create process_in proc.inchan in let the = Thread.create begin fun () -> process_err proc.errchan; Thread.join thi; (match tho with Some t -> Thread.join t | _ -> ()); if mode = `ASYNC then final() end () in match mode with | `SYNC -> Thread.join the; Thread.join thi; (match tho with Some t -> Thread.join t | _ -> ()); final(); `SUCCESS | `ASYNC -> `PID proc.pid with (Unix.Unix_error _) as ex -> `ERROR ex  let sync ?working_directory ?env ?at_exit ?process_in ?process_out ?process_err ?binary program args = match exec `SYNC ?working_directory ?env ?at_exit ?process_in ?process_out ?process_err ?binary program args with | `SUCCESS -> None | `ERROR ex -> Some ex | `PID _ -> assert false  let async ?working_directory ?env ?at_exit ?process_in ?process_out ?process_err ?binary program args = match exec `ASYNC ?working_directory ?env ?at_exit ?process_in ?process_out ?process_err ?binary program args with | `SUCCESS -> assert false | (`ERROR _) as x -> x | (`PID _) as x -> x end
module Task = struct type kind = [ `CLEAN | `CLEANALL | `ANNOT | `COMPILE | `RUN | `OTHER] type phase = Before_clean | Clean | After_clean | Before_compile | Compile | After_compile type t = { mutable et_name                  : string; mutable et_env                   : (bool * string) list; mutable et_env_replace           : bool;                                mutable et_dir                   : string;                                                                                            mutable et_cmd                   : string; mutable et_args                  : (bool * string) list; mutable et_phase                 : phase option; mutable et_always_run_in_project : bool; mutable et_always_run_in_script  : bool; mutable et_readonly              : bool; mutable et_visible               : bool; } let string_of_phase = function | Before_clean -> "Before_clean" | Clean -> "Clean" | After_clean -> "After_clean" | Before_compile -> "Before_compile" | Compile -> "Compile" | After_compile -> "After_compile" let descr_of_phase = function | Before_clean -> "Pre-clean" | Clean -> "Clean" | After_clean -> "Post-clean" | Before_compile -> "Pre-build" | Compile -> "Build" | After_compile -> "Post-build" let phase_of_string = function | "Before_clean" -> Before_clean | "Clean" -> Clean | "After_clean" -> After_clean | "Before_compile" -> Before_compile | "Compile" -> Compile | "After_compile" -> After_compile | _ -> failwith "phase_of_string" let create ~name ~env ?(env_replace=false) ~dir ~cmd ~args ?phase ?(run_in_project=false) ?(run_in_script=true) ?(readonly=false) ?(visible=true) () = { et_name                  = name; et_env                   = env; et_env_replace           = env_replace; et_dir                   = dir; et_cmd                   = cmd; et_args                  = args; et_phase                 = phase; et_always_run_in_project = run_in_project; et_always_run_in_script  = run_in_script; et_readonly              = readonly; et_visible               = visible; }  let handle f task = let tenv = Array.of_list task.et_env in let env = if task.et_env_replace then Array.concat [                        tenv] else (Array.concat [tenv                       ; (Array.map (fun e -> true, e) (Unix.environment()))]) in let env = List.filter (fun (e, _) -> e) (Array.to_list env) in let env = Array.of_list (List.map (fun (_, v) -> v) env) in let prog = task.et_cmd in let dir = if task.et_dir <> "" then task.et_dir else (Sys.getcwd ()) in let args =  task.et_args |> List.filter (fun (e, _) -> e) |> List.map (fun (_, x) -> x) in f ~env ~dir ~prog ~args;; end
module Build_script_command = struct open Printf type t = [`Show | `Build | `Install | `Uninstall | `Install_lib | `Clean | `Distclean] let commands = [`Show; `Build; `Install; `Uninstall; `Install_lib; `Clean; `Distclean] exception Unrecognized_command of string let string_of_command = function | `Show -> "show" | `Build -> "build" | `Install -> "install" | `Uninstall -> "uninstall" | `Install_lib -> "install-lib" | `Clean -> "clean" | `Distclean -> "distclean" let command_of_string = function | "show" -> `Show | "build" -> `Build | "install" -> `Install | "uninstall" -> `Uninstall | "install-lib" -> `Install_lib | "clean" -> `Clean | "distclean" -> `Distclean | x -> raise (Unrecognized_command (sprintf "`%s' is not a recognized command." x));; let code_of_command = function | `Show -> "`Show" | `Build -> "`Build" | `Install -> "`Install" | `Uninstall -> "`Uninstall" | `Install_lib -> "`Install_lib" | `Clean -> "`Clean" | `Distclean -> "`Distclean" end
module Oebuild_util = struct open Printf let (!$) = Filename.chop_extension let (//) = Filename.concat let (^^^) = Filename.check_suffix let (<@) = List.mem let win32 = (fun a b -> match Sys.os_type with "Win32" -> a | _ -> b) let re_spaces = Str.regexp " +" let redirect_stderr_to_null = if Sys.os_type = "Win32" then " 2>NUL" else " 2>/dev/null"  let format_int n = let n = string_of_int n in let i = ref (String.length n - 3) in let res = ref "" in while !i >= 0 do res := (if !i > 0 then "," else "") ^ (String.sub n !i 3) ^ !res; i := !i - 3; done; (String.sub n 0 (!i + 3)) ^ !res;; let unquote = let re = Str.regexp "^['\"]\\(.*\\)['\"]$" in fun x -> if Str.string_match re x 0 then Str.matched_group 1 x else x let split_space = Str.split re_spaces  let lpad txt c width = let result = (String.make width c) ^ txt in String.sub result (String.length result - width) width;;  let rpad txt c width = let result = txt ^ (String.make width c) in String.sub result 0 width;;  let dot_leaders ?(prefix="") ?(postfix="") ?(right_align=false) properties = let prefix_length = String.length prefix in let maxl = List.fold_left begin fun maxl (x, _) -> let len = prefix_length + String.length x in max maxl len end 0 properties in let lpad x = if right_align then let len = List.fold_left begin fun maxr (_, y) -> let len = String.length y in max maxr len end 0 properties in lpad x ' ' len else x in List.map (fun (n, v) -> Printf.sprintf "%s : %s%s" (rpad (prefix ^ n ^ " ") '.' maxl) (lpad v) postfix) properties ;;  let crono ?(label="Time") f x = let finally time = Printf.fprintf stdout "[CRONO] %s: %f sec." label (Unix.gettimeofday() -. time); print_newline(); in let time = Unix.gettimeofday() in let result = try f x with e -> begin finally time; raise e end in finally time; result  let remove_dupl l = List.rev (List.fold_left (fun acc y -> if List.mem y acc then acc else y :: acc) [] l)  let remove_file ?(verbose=false) filename = try if Sys.file_exists filename then (Sys.remove filename; if verbose then print_endline filename) with Sys_error ex -> eprintf "%s\n%!" ex  let command ?(echo=true) cmd = if echo then (printf "%s\n%!" cmd); let exit_code = Sys.command cmd in Stdlib.flush stderr; Stdlib.flush stdout; exit_code  let rm = win32 "DEL /F /Q" "rm -f"  let copy_file ic oc = let buff = Bytes.create 0x1000 in let rec copy () = let n = input ic buff 0 0x1000 in if n = 0 then () else (output oc buff 0 n; copy()) in copy() let cp ?(echo=true) src dst = let ic = open_in_bin src in let oc = open_out_bin dst in if echo then (printf "%s -> %s\n%!" src dst); let finally () = close_out oc; close_in ic in try copy_file ic oc; finally() with ex -> (finally(); raise ex)  let rec mkdir_p d = if not (Sys.file_exists d) then begin mkdir_p (Filename.dirname d); printf "mkdir -p %s\n%!" d; (Unix.mkdir d 0o755) end  let replace_extension_to_ml filename = if Filename.check_suffix filename ".cmx" then (Filename.chop_extension filename) ^ ".ml" else if Filename.check_suffix filename ".cmi" then (Filename.chop_extension filename) ^ ".mli" else filename ;;  let split_prog_args x = match split_space x with | h :: t -> h, Array.of_list t | _ -> assert false  let get_effective_command = let re_verbose = Str.regexp " -verbose" in fun ?(linkpkg=false) ocamlfind -> try let cmd = sprintf "%s%s -verbose %s" ocamlfind (if linkpkg then " -linkpkg" else "") redirect_stderr_to_null in let lines = Shell.get_command_output cmd in let effective_compiler = List.find (fun line -> String.sub line 0 2 = "+ ") lines in let effective_compiler = Str.string_after effective_compiler 2  in let effective_compiler = Str.replace_first re_verbose "" effective_compiler in let a, b = split_prog_args effective_compiler in (if Sys.win32 then a ^ ".exe" else a), b with Not_found -> split_prog_args ocamlfind ;; end
module Oebuild_table = struct open Printf let dummy_crc = String.make 32 '0'  type t = (string, float) Hashtbl.t let oebuild_times_filename = ".oebuild" let (^^) filename opt = filename ^ (if opt then ".opt" else ".byt") let find (table : t) filename opt = Hashtbl.find table (filename ^^ opt) let add (table : t) filename opt = Hashtbl.replace table (filename ^^ opt) let remove (table : t) filename opt = Hashtbl.remove table (filename ^^ opt)  let read () = if not (Sys.file_exists oebuild_times_filename) then begin let ochan = open_out_bin oebuild_times_filename in Marshal.to_channel ochan (Hashtbl.create 7) []; close_out ochan end; let ichan = open_in_bin oebuild_times_filename in let times = Marshal.from_channel ichan in close_in ichan; (times : t)  let write (times : t) = if Hashtbl.length times > 0 then begin let ochan = open_out_bin oebuild_times_filename in Marshal.to_channel ochan times []; close_out ochan end  let update = let get_last_compiled_time ~opt cache filename = try let time = find cache filename opt in let ext = if opt then "cmx" else "cmo" in let cm = sprintf "%s.%s" (Filename.chop_extension filename) ext in if Sys.file_exists cm then time else begin remove cache filename opt; raise Not_found end with Not_found -> 0.0 in fun ~opt (cache : t) filename -> let ctime = get_last_compiled_time ~opt cache filename in if ctime > 0.0 && ((Unix.stat filename).Unix.st_mtime) >= ctime then begin remove cache filename opt; true end else ctime = 0.0 ;; end
module Oebuild_dag = struct module type ENTRY = sig type key type t val equal : t -> t -> bool val hash : t -> int val to_string : t -> string end module Make (Entry : ENTRY) = struct type t = (Entry.key, entry) Hashtbl.t and entry = { key                  : Entry.key; node                 : Entry.t; mutable dependants   : entry list; mutable dependencies : entry list; } let length = Hashtbl.length let set_dependants (dag : t) = Hashtbl.iter begin fun _ entry -> List.iter begin fun node -> node.dependants <- entry :: node.dependants end entry.dependencies end dag let get_leaves : t -> entry list = fun dag -> Hashtbl.fold begin fun _ entry acc -> if entry.dependencies = [] then entry :: acc else acc end dag [];; let remove_leaf : t -> entry -> unit = fun dag leaf -> if Hashtbl.mem dag leaf.key then if leaf.dependencies <> [] then failwith "Not a leaf" else begin Hashtbl.iter begin fun _ entry -> entry.dependencies <- List.filter (fun d -> d.key <> leaf.key) entry.dependencies; end dag; Hashtbl.remove dag leaf.key; end;; end end
module Oebuild_dep = struct open Printf type ocamldeps = (string, bool * string list) Hashtbl.t exception Loop_found of string let re1 = Str.regexp " ?:\\( \\|$\\)" let re3 = Str.regexp " " let split_nl = Str.split (Str.regexp "\n")  let ocamldep_command ?pp ?(slash=true) ?(search_path="") () = sprintf "%s%s %s -native -one-line %s" (Ocaml_config.ocamldep()) (match pp with Some pp when pp <> "" -> " -pp " ^ pp | _ -> "" ) search_path (if slash then "-slash" else "");;  let run_ocamldep_on ~ignore_stderr ~verbose ?pp ?slash ?search_path filenames = let redirect_stderr = if ignore_stderr then Oebuild_util.redirect_stderr_to_null else "" in let cmd = ocamldep_command ?pp ?slash ?search_path () in let cmd = sprintf "%s %s %s" cmd filenames redirect_stderr in if verbose then (printf "%s\n%!" cmd); Shell.get_command_output cmd  let ocamldep ?times ?pp ?(ignore_stderr=false) ?(verbose=false) ?slash ?search_path filenames = let table : ocamldeps = Hashtbl.create 7 in if String.trim filenames <> "" then begin let entries = run_ocamldep_on ~ignore_stderr ~verbose ?pp ?slash ?search_path filenames in let replace = match times with | Some (times, opt) ->  fun table target dependencies -> let ml = Oebuild_util.replace_extension_to_ml target in let changed = Oebuild_table.update ~opt times ml in  Hashtbl.replace table target (changed, dependencies) | _ -> fun table target dependencies -> Hashtbl.replace table target (true, dependencies) in let open! Oebuild_util in List.iter begin fun entry -> match Str.split re1 entry with | key :: _ when key ^^^ ".cmo" -> () | key :: [] -> replace table key [] | [key; deps] -> let deps = Str.split re3 deps in replace table key deps; | _ -> eprintf "%s\n%s\n%!" filenames entry; assert false end entries; end; table;;  let ocamldep_toplevels ?times ?pp ?ignore_stderr ?verbose ?slash ?(search_path="") toplevel_modules = let search_path, filenames = List.fold_left begin fun (sp, fn) x -> let dir = Filename.dirname x in if dir = "." then sp, ("*.ml *.mli" :: fn) else (" -I " ^ dir) :: sp, (sprintf "%s/*.ml %s/*.mli" dir dir) :: fn end ([search_path], []) toplevel_modules in let search_path = String.concat "" (Oebuild_util.remove_dupl search_path) in let filenames = String.concat " " (Oebuild_util.remove_dupl filenames) in ocamldep ?times ?pp ?ignore_stderr ~search_path ?verbose ?slash filenames  let update_dependants dag = let dependency_changed target dag = match Hashtbl.find dag target with | _, deps -> List.fold_left (fun acc dep -> acc || Hashtbl.find dag dep |> fst) false deps | exception Not_found -> false in let counter = ref 0 in Hashtbl.filter_map_inplace ( (fun target (changed, deps) -> if changed then Some (changed, deps) else if dependency_changed target dag then begin incr counter; Some (true, deps) end else Some (false, deps))) dag; !counter  let ocamldep_recursive ?times ?pp ?(ignore_stderr=false) ?(verbose=false) ?slash ?search_path toplevel_modules = let dag : ocamldeps = Hashtbl.create 17 in let rec loop ~toplevel_modules = let filenames = String.concat " " toplevel_modules in let ocamldeps = ocamldep ?times ?pp ~ignore_stderr ~verbose ?slash ?search_path filenames in let new_tops = Hashtbl.fold begin fun key (changed, deps) acc -> Hashtbl.add dag key (changed, deps); List.rev_append deps acc end ocamldeps [] in let new_tops = List.filter (fun tl -> not (Hashtbl.mem dag tl)) new_tops in let new_tops = Oebuild_util.remove_dupl new_tops in let new_tops = List.map Oebuild_util.replace_extension_to_ml new_tops in if new_tops <> [] then loop ~toplevel_modules:new_tops in loop ~toplevel_modules; while update_dependants dag > 0 do () done; dag  let sort_dependencies (dag : ocamldeps) = let dag = Hashtbl.copy dag in let get_leaves dag = Hashtbl.fold begin fun key (_            , deps) acc -> let deps = List.filter (Hashtbl.mem dag) deps in if deps = [] then key :: acc else acc end dag [] in let rec loop res = match get_leaves dag with | [] -> res | leaves -> List.iter (Hashtbl.remove dag) leaves; loop (List.rev_append leaves res); in List.rev (Oebuild_util.remove_dupl (loop [])) ;;  let find_dependants = let re = Str.regexp "\\(.+\\.mli?\\) ?: ?\\(.*\\)" in let re1 = Str.regexp "\r?\n" in let re2 = Str.regexp " " in fun ~dirname ~modname ->  let dir = if dirname = Filename.current_dir_name then "" else (dirname ^ "/") in let cmd = sprintf "%s -modules -native %s*.ml %s*.mli%s" (Ocaml_config.ocamldep()) dir dir Oebuild_util.redirect_stderr_to_null in printf "%s (%s)\n%!" cmd modname; let ocamldep = String.concat "\n" (Shell.get_command_output cmd) in let entries = Str.split re1 ocamldep in let entries = List.map begin fun entry -> if Str.string_match re entry 0 then begin let filename = Str.matched_group 1 entry in let modules = Str.matched_group 2 entry in (filename, (Str.split re2 modules)) end else (assert false) end entries in let dependants = ref [] in let rec loop modname = List.iter begin fun (filename, modules) -> if List.mem modname modules then begin if not (List.mem filename !dependants) then begin dependants := filename :: !dependants; let prefix = Filename.chop_extension filename in let prefix_mli = prefix ^ ".mli" in if List.mem_assoc prefix_mli entries then (dependants := prefix_mli :: !dependants;); let mdep = String.capitalize_ascii (Filename.basename prefix) in ignore (loop mdep); end end end entries; !dependants in loop modname  let find_dependants ~path ~modname = let dependants = List.map (fun dirname -> find_dependants ~dirname ~modname) path in List.flatten dependants ;;   let find_dep ?pp ?(ignore_stderr=false) ?(echo=true) target = let dir = Filename.dirname target in let filenames = (match dir with "." -> "*.mli" | _ -> dir ^ "/" ^ "*.mli *.mli") ^ " " ^ (match dir with "." -> "*.ml" | _ -> dir ^ "/" ^ "*.ml *.ml") in let search_path = Ocaml_config.expand_includes dir in let table = ocamldep ?pp ~ignore_stderr ~verbose:echo ~search_path filenames in let target = (Filename.chop_extension target) ^ ".cmx" in let anti_loop = ref [] in let result = ref [] in let rec find_chain target = if (List.mem target !anti_loop) && (not (List.mem target !result)) then (raise (Loop_found (String.concat " " (List.map Oebuild_util.replace_extension_to_ml (target :: !anti_loop))))); anti_loop := target :: (List.filter ((<>) target) !anti_loop); try if not (List.mem target !result) then begin match Hashtbl.find table target with | (_, []) -> result := target :: !result; | (_, deps) -> List.iter find_chain deps; result := target :: !result; end with Not_found ->  (kprintf failwith "Dep: %s" target) in find_chain target; List.rev (                                     !result) ;;  let find ?pp ?ignore_stderr ?(echo=true) targets = let deps = List.map (find_dep ?pp ?ignore_stderr ~echo) targets in let deps = List.flatten deps in List.rev (List.fold_left begin fun acc x -> if not (List.mem x acc) then x :: acc else acc end [] deps) ;; end
module Oebuild_dep_dag = struct                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 open Oebuild_util open Printf type t = (string, string list) Hashtbl.t type dag_option = Dag of t * Oebuild_dep.ocamldeps | Cycle of string list exception Cycle_exception of string list  let array_exists from p a = try for i = from to Array.length a - 1 do if p a.(i) then raise Exit done; false with Exit -> true  let reduce : t -> unit = function table -> let rec (<-?-) x y = let deps = try Hashtbl.find table y with Not_found -> [] in (List.mem x deps) || (List.exists ((<-?-) x) deps) in let is_descendant =                              (<-?-) in let reduce ll = let stop = ref "" in let rec reduce' ll = let len = Array.length ll in if len <= 1 then ll else let fst = ll.(0) in if fst = !stop then ll else begin let len = len - 1 in if array_exists 1 (is_descendant fst) ll then begin let tail = Array.make len "" in Array.blit ll 1 tail 0 len; reduce' tail end else begin if !stop = "" then (stop := fst); Array.blit ll 1 ll 0 len; ll.(len) <- fst; reduce' ll end end in Array.to_list (reduce' (Array.of_list ll)) in Hashtbl.iter (fun key deps -> Hashtbl.replace table key (reduce deps)) table ;;  let dot_of_dag (dag : t) = let buf = Buffer.create 1000 in Buffer.add_string buf "digraph {\n"; Hashtbl.iter begin fun key -> List.iter (kprintf (Buffer.add_string buf) "%S -> %S;\n" key) end dag; Buffer.add_string buf "}\n"; Buffer.contents buf;;  let find_toplevels ocamldeps = let all_deps = Hashtbl.fold begin fun key (_, deps) acc -> Printf.printf "OCAMLDEPS: %-30s -> [%s]\n%!" key (String.concat ", " deps); List.rev_append deps acc end ocamldeps [] in let toplevels = Hashtbl.fold begin fun key _ acc -> if List.mem key all_deps then acc else key :: acc end ocamldeps []; in Printf.printf "\nTOPLEVELS: %s\n\n%!" (String.concat ", " toplevels); toplevels ;;  let create_dag ?times ?pp ~toplevel_modules ~verbose () = let crono = if verbose >= 4 then crono else fun ?label:_ f x -> f x in let dirs = List.map Filename.dirname toplevel_modules in let dirs = List.filter ((<>) ".") dirs in let dirs = remove_dupl dirs in let search_path = List.map Ocaml_config.expand_includes dirs in let search_path = String.concat " " search_path in let ocamldeps = Oebuild_dep.ocamldep_recursive ?times ~search_path ?pp ~verbose:false toplevel_modules in if verbose >= 4 then Printf.printf "OCAMLDEPS LENGTH: %d\n%!" (Hashtbl.length ocamldeps);  try let table = Hashtbl.create 17 in let rec add path node = if List.mem node path then raise (Cycle_exception (node :: path)) else begin let changed, children = try Hashtbl.find ocamldeps node with Not_found -> false, [] in if not (Hashtbl.mem table node) then begin if changed then Hashtbl.add table node children; List.iter (add (node :: path)) children; end end in let toplevel_modules_cmx = List.map (fun filename -> (Filename.chop_extension filename) ^ ".cmx") toplevel_modules in let need_find_tl = List.exists (fun tl -> not (Hashtbl.mem ocamldeps tl)) toplevel_modules_cmx in  let toplevel_modules_cmx = if need_find_tl then crono ~label:"Oebuild_dep_dag.create_dag, find_toplevels" find_toplevels ocamldeps else toplevel_modules_cmx in crono ~label:"Oebuild_dep_dag.create_dag, add" (List.iter (add [])) toplevel_modules_cmx; crono ~label:"Oebuild_dep_dag.create_dag, reduce" reduce table; if verbose >= 4 then begin Printf.printf "DAG: number of nodes = %d\n%!" (Hashtbl.length table); Hashtbl.iter begin fun node children -> Printf.printf "DAG: %-40s : [%s]\n%!" node (String.concat "; " children); end table; end; Dag ((table : t), ocamldeps) with Cycle_exception cycle -> match cycle with | hd :: _ -> let cycle = let found = ref false in List.filter begin fun x -> found := !found || x = hd; !found end (List.rev cycle) in Cycle (             cycle) | [] -> assert false ;; end
module Oebuild_parallel = struct                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 open Printf module Dep_dag = Oebuild_dep_dag type process_output = { command           : string; args              : string array; filename          : string; mutable exit_code : int; mutable err       : Buffer.t; mutable out       : Buffer.t; } module NODE = struct type key = string type t = { nd_create_command     : (string -> (string * string array) option); nd_at_exit            : (process_output -> unit); nd_filename           : string; mutable nd_processing : bool; } let equal a b = a.nd_filename = b.nd_filename let hash x = Hashtbl.hash x.nd_filename let to_string x = x.nd_filename end type node = NODE.t = { nd_create_command     : (string -> (string * string array) option); nd_at_exit            : (process_output -> unit); nd_filename           : string; mutable nd_processing : bool; } module Dag = Oebuild_dag.Make(NODE) type t = (NODE.key, Dag.entry) Hashtbl.t type dag = { graph     : t; ocamldeps : (string, bool * string list) Hashtbl.t; mutex     : Mutex.t; }  let print_results err_outputs ok_outputs = flush_all();  let sep = "\n" in List.iter begin fun process_output -> let has_out = Buffer.length process_output.out > 0 in let has_err = Buffer.length process_output.err > 0 in if has_out then printf "%s %s\n%s\n%s%!" process_output.command (String.concat " " (Array.to_list process_output.args)) (Buffer.contents process_output.out) sep; if has_err then begin  eprintf "%s\n%s%!" (Buffer.contents process_output.err) sep; end end ok_outputs; flush_all(); List.iter begin fun process_output -> let has_out = Buffer.length process_output.out > 0 in let has_err = Buffer.length process_output.err > 0 in  let cmd = process_output.command ^ " " ^ (String.concat " " (Array.to_list process_output.args)) in if has_out then printf "%s\n%s\n%s%!" cmd (Buffer.contents process_output.out) sep; if has_err then begin  if Buffer.length process_output.err > 0 then eprintf "%s\n%s%!" (Buffer.contents process_output.err) sep; end; end err_outputs; flush_all() ;;  let create_dag ?times ?pp ~cb_create_command ~cb_at_exit ~toplevel_modules ~verbose () = match Dep_dag.create_dag ?times ?pp ~toplevel_modules ~verbose () with | Dep_dag.Cycle cycle -> kprintf failwith "Cycle: %s" (String.concat "->" cycle) | Dep_dag.Dag (dag', ocamldeps) -> let dag = Hashtbl.create 17 in Hashtbl.iter begin fun filename _deps -> let node = { nd_create_command = cb_create_command; nd_at_exit        = cb_at_exit; nd_filename       = filename; nd_processing     = false } in Hashtbl.add dag filename { Dag.key      = filename; node         = node; dependencies = []; dependants   = [] } end dag'; Hashtbl.iter begin fun node deps -> try let node = Hashtbl.find dag node in List.iter begin fun dep -> try let e = Hashtbl.find dag dep in node.dependencies <- e :: node.dependencies; with Not_found -> () end deps; with Not_found -> assert false end dag'; Dag.set_dependants dag; { graph = dag; ocamldeps; mutex = Mutex.create() } ;; let job_counter = ref 1 let job_mutex = Mutex.create ()  let create_process ?(jobs=0) ~verbose cb_create_command cb_at_exit dag leaf errors messages = leaf.Dag.node.NODE.nd_processing <- true; let filename = Oebuild_util.replace_extension_to_ml leaf.Dag.node.NODE.nd_filename in match cb_create_command filename with | Some (command, args) when jobs = 0 || !job_counter <= jobs -> if verbose >= 4 then Printf.printf "Oebuild_parallel.create_process [%d/%d]: %s %s\n%!" !job_counter jobs                                command (String.concat " " (Array.to_list args)) else if verbose >= 2 then print_endline (String.concat " " (command :: (Array.to_list args))); let output = { command; args; filename; exit_code  = 0; err        = Buffer.create 10; out        = Buffer.create 10 } in let at_exit = function | None ->  if Buffer.length output.err > 0 then (errors := output :: !errors) else messages := output :: !messages; Mutex.lock dag.mutex; Dag.remove_leaf dag.graph leaf; Mutex.unlock dag.mutex;  Mutex.lock job_mutex; decr job_counter; Mutex.unlock job_mutex;  cb_at_exit output | Some ex -> Printf.eprintf "File \"oebuild_parallel.ml\": %s\n%s\n%!" (Printexc.to_string ex) (Printexc.get_backtrace()); in let process_in = Spawn.loop (fun stdin -> Buffer.add_string output.out (input_line stdin); Buffer.add_char output.out '\n') in let process_err = Spawn.loop (fun stderr -> Buffer.add_string output.err (input_line stderr); Buffer.add_char output.err '\n') in  Mutex.lock job_mutex; incr job_counter; Mutex.unlock job_mutex;  begin match Spawn.async ~at_exit ~process_in ~process_err command args with `ERROR ex -> () | `PID _ -> () end; | None -> if verbose >= 4 then Printf.printf "Oebuild_parallel.create_process: %30s (No command)\n%!" filename; Mutex.lock dag.mutex; Dag.remove_leaf dag.graph leaf; Mutex.unlock dag.mutex; | _ -> leaf.Dag.node.NODE.nd_processing <- false; ;;  let process_parallel ?jobs ~verbose dag = let open NODE in let errors = ref [] in let messages = ref [] in let leaves = ref [] in begin try while leaves := Dag.get_leaves dag.graph; !leaves <> [] do List.iter begin fun leaf -> if not leaf.Dag.node.nd_processing then (create_process ?jobs ~verbose leaf.Dag.node.nd_create_command leaf.Dag.node.nd_at_exit dag leaf errors messages |> ignore) end !leaves;  if !errors <> [] then raise Exit; Thread.delay 0.005; done; with Exit -> () end; let errors = List.rev !errors in let messages = List.rev !messages in print_results errors messages; ;; end
module Oebuild = struct open Printf open Oebuild_util module Table = Oebuild_table type compilation_type = Bytecode | Native | Unspecified type output_type = Executable | Library | Plugin | Pack | External type build_exit = Built_successfully | Build_failed of int type process_output = Oebuild_parallel.process_output = { command           : string; args              : string array; filename          : string; mutable exit_code : int; mutable err       : Buffer.t; mutable out       : Buffer.t; } let string_of_compilation_type = function | Bytecode -> "Bytecode" | Native -> "Native" | Unspecified -> "Unspecified" let string_of_output_type = function | Executable -> "Executable" | Library -> "Library" | Plugin -> "Plugin" | Pack -> "Pack" | External -> "External";; let ocamlc = Ocaml_config.ocamlc() let ocamlopt = Ocaml_config.ocamlopt() let ocamllib = Ocaml_config.ocamllib()  let check_package_list = let redirect_stderr = if Sys.os_type = "Win32" then " 1>NUL 2>NUL" else " 1>/dev/null 2>/dev/null" in fun package_list -> let package_list = Str.split (Str.regexp "[, ]") package_list in let available, unavailable = List.partition begin fun package -> kprintf (Oebuild_util.command ~echo:false) "ocamlfind query %s %s" package redirect_stderr = 0 end package_list in if unavailable <> [] then begin eprintf "Warning (oebuild): the following packages are not found: %s\n" (String.concat ", " unavailable); end; String.concat "," available;;  let get_compiler_command ?(times : Table.t option) ~opt ~compiler ~cflags ~includes ~filename ~verbose () = if Sys.file_exists filename then begin try begin match times with | Some times -> ignore (Table.find times filename opt); None | _ -> raise Not_found end with Not_found -> begin let verbose_opt = if verbose >= 5 then "-verbose" else "" in let compiler, args = compiler in Some (compiler, Array.concat [ [| "-c"; |] ; args; (Array.of_list (Str.split re_spaces cflags)); (Array.of_list (Str.split re_spaces includes)); [| verbose_opt; filename |] ]) end end else None  let compile ?(times : Table.t option) ~opt ~compiler ~cflags ~includes ~filename ~verbose () = let command = get_compiler_command ?times ~opt ~compiler ~cflags ~includes ~filename ~verbose () in match command with | Some (cmd, args) -> let exit_code = let cmd_line = String.concat " " (cmd :: (Array.to_list args)) in Oebuild_util.command ~echo:(verbose >= 2) cmd_line in Option.iter (fun times -> Table.add times filename opt (Unix.gettimeofday())) times; exit_code | _ -> 0  let link ~compilation ~compiler ~outkind ~lflags ~includes ~libs ~outname ~deps ~verbose () = let opt = compilation = Native && ocamlopt <> None in let libs = if            outkind <> Executable then "" else let ext = if opt then "cmxa" else "cma" in let libs = List.map begin fun x -> if Filename.check_suffix x ".o" then begin let x = Filename.chop_extension x in let ext = if opt then "cmx" else "cmo" in sprintf "%s.%s" x ext end else if Filename.check_suffix x ".obj" then begin sprintf "%s" x end else (sprintf "%s.%s" x ext) end libs in String.concat " " libs in let deps = String.concat " " deps in let process_exit = let command, args = compiler in let args = Array.concat [ args;                                                                         [| if verbose >= 5 then "-verbose" else ""; (match outkind with Library -> "-a" | Plugin when opt -> "-shared" | Plugin -> "" | Pack -> "-pack" | Executable | External -> ""); "-o"; outname |]; (Array.of_list (split_space lflags)); (Array.of_list (split_space includes)); (Array.of_list (split_space libs)); (Array.of_list (split_space deps)); ] in if verbose >= 2 then print_endline (String.concat " " (command :: (Array.to_list args))); Spawn.sync command args in match process_exit with | None -> 0 | Some ex -> -9997 ;;  let get_output_name ~compilation ~outkind ~outname ?(dontaddopt=false) () = let o_ext = match outkind with | Library when compilation = Native -> ".cmxa" | Library -> ".cma" | Executable when compilation = Native && dontaddopt -> win32 ".exe" "" | Executable when compilation = Native -> ".opt" ^ (win32 ".exe" "") | Executable -> win32 ".exe" "" | Plugin when compilation = Native -> ".cmxs" | Plugin -> ".cma" | Pack -> ".cmx" | External -> "" in let name = if outname = "" then "a" else unquote outname in name ^ o_ext ;;  let install ~compilation ~outkind ~outname ~deps ~path ~ccomp_type = let dest_outname = Filename.basename outname in match outkind with | Library -> let path = let path = ocamllib // path in mkdir_p path; path in cp outname (path // dest_outname); let deps_mod = List.map Filename.chop_extension deps in let deps_mod = remove_dupl deps_mod in let cmis = List.map (fun d -> sprintf "%s.cmi" d) deps_mod in let mlis = List.map (fun cmi -> sprintf "%s.mli" (Filename.chop_extension cmi)) cmis in let mlis = List.filter Sys.file_exists mlis in List.iter (fun x -> ignore (cp x (path // (Filename.basename x)))) cmis; List.iter (fun x -> ignore (cp x (path // (Filename.basename x)))) mlis; if compilation = Native then begin let ext = match ccomp_type with Some "msvc" -> ".lib" | Some _ ->  ".a" | None -> assert false in let basename = sprintf "%s%s" (Filename.chop_extension outname) ext in cp basename (path // (Filename.basename basename)); end; | Executable | Plugin | Pack | External -> eprintf "\"Oebuild.install\" not implemented for Executable, Plugin, Pack or External." ;;  let run_output ~outname ~args = let args = List.rev args in if Sys.win32 then begin let cmd = Str.global_replace (Str.regexp "/") "\\\\" outname in let cmd = Filename.current_dir_name // cmd in   Spawn.sync ~process_in:Spawn.redirect_to_stdout ~process_err:Spawn.redirect_to_stderr cmd (Array.of_list args) |> ignore end else begin let cmd = Filename.current_dir_name // outname in  let args = cmd :: args in let args = Array.of_list args in Unix.execv cmd args end ;;  let sort_dependencies ~deps subset = let result = ref [] in List.iter begin fun x -> if List.mem x subset then (result := x :: !result) end deps; List.rev !result ;;  let serial_compile ~compilation ~times ~compiler ~cflags ~includes ~toplevel_modules:_ ~deps ~verbose = let crono = if verbose >= 3 then crono else fun ?label:_ f x -> f x in let compilation_exit = ref 0 in begin try let opt = compilation = Native in let compiler_output = Buffer.create 100 in let try_compile filename = let compile_exit = Table.update ~opt times filename |> ignore; let exit_code = compile ~times ~opt ~compiler ~cflags ~includes ~filename ~verbose () in if exit_code <> 0 then (Table.remove times filename opt); exit_code in if Buffer.length compiler_output > 0 then (eprintf "%s\n%!" (Buffer.contents compiler_output)); compile_exit in crono ~label:"Serial compilation" (List.iter begin fun filename -> compilation_exit := try_compile filename; if !compilation_exit <> 0 then (raise Exit) end) deps; with Exit -> () end; !compilation_exit  let parallel_compile ~compilation ?times ?pp ~compiler ~cflags ~includes ~toplevel_modules ~verbose ?jobs () = let crono = if verbose >= 3 then crono else fun ?label:_ f x -> f x in let crono4 = if verbose >= 4 then crono else fun ?label:_ f x -> f x in let opt = compilation = Native in let cb_create_command filename = get_compiler_command ~opt ~compiler ~cflags ~includes ~filename ~verbose () in let cb_at_exit process_output = Option.iter begin fun times -> if process_output.exit_code = 0 then Table.add times process_output.filename opt (Unix.gettimeofday()) else Table.remove times process_output.filename opt; end times in let times = Option.map (fun t -> t, opt) times in let dag = crono4 ~label:"Oebuild_parallel.create_dag (ocamldep+add+reduce)" (fun () -> Oebuild_parallel.create_dag ?times ?pp ~cb_create_command ~cb_at_exit ~toplevel_modules ~verbose ()) () in crono ~label:"Parallel compilation" (Oebuild_parallel.process_parallel ?jobs ~verbose) dag; let sorted_deps = Oebuild_dep.sort_dependencies dag.ocamldeps in let deps_ml = List.map replace_extension_to_ml sorted_deps in sorted_deps, deps_ml, 0  let build ~compilation ~package ~includes ~libs ~other_mods ~outkind ~compile_only ~thread ~vmthread ~annot ~bin_annot ~pp ?inline ~cflags ~lflags ~outname ~deps ~dontlinkdep ~dontaddopt               ~toplevel_modules ?(jobs=0) ?(serial=false) ?(prof=false) ?(verbose=2) () = let crono = if verbose >= 3 then crono else fun ?label f x -> f x in let crono4 = if verbose >= 4 then crono else fun ?label f x -> f x in let libs = unquote libs in let cflags = unquote cflags in let lflags = unquote lflags in let includes = unquote includes in let package = unquote package in if verbose >= 1 then begin printf "\n%s %s" (string_of_compilation_type compilation) (string_of_output_type outkind); if outname <> ""    then (printf " %s\n" outname); if dontlinkdep      then (printf "  ~dontlinkdep\n"); if dontaddopt       then (printf "  ~dontaddopt\n"); if compile_only     then (printf "  ~compile_only\n"); if thread           then (printf "  ~thread\n"); if vmthread         then (printf "  ~vmthread\n"); if bin_annot        then (printf "  ~binannot\n"); if package <> ""    then (printf "  ~package ........ : %s\n" package); if includes <> ""   then (printf "  ~search_path .... : %s\n" includes); if libs <> ""       then (printf "  ~libs ........... : %s\n" libs); if other_mods <> "" then (printf "  ~other_mods ..... : %s\n" other_mods); (match inline with Some n -> printf "  ~inline ......... : %d\n" n | _ -> ()); if cflags <> ""     then (printf "  ~cflags ......... : %s\n" cflags); if lflags <> ""     then (printf "  ~lflags ......... : %s\n" cflags); if toplevel_modules <> [] then (printf "  ~toplevel_modules : %s\n" (String.concat "," toplevel_modules)); if serial           then (printf "  ~serial ......... : %b\n" serial) else (printf "  ~jobs ........... : %d\n" jobs); printf "  ~verbose ........ : %d\n" verbose; if verbose >= 2 then (printf "\n"); printf "%!"; end;  let includes = ref includes in includes := Ocaml_config.expand_includes !includes;  let libs = split_space libs in  let cflags = ref cflags in let lflags = ref lflags in  if thread then (cflags := !cflags ^ " -thread"; lflags := !lflags ^ " -thread"); if vmthread then (cflags := !cflags ^ " -vmthread"; lflags := !lflags ^ " -vmthread"); if annot then (cflags := !cflags ^ " -annot"); if bin_annot then (cflags := !cflags ^ " -bin-annot"); if pp <> "" then (cflags := !cflags ^ " -pp " ^ pp); let pp = if pp <> "" then Some pp else None in  begin match inline with | Some inline when compilation = Native -> let inline = string_of_int inline in cflags := !cflags ^ " -inline " ^ inline; lflags := !lflags ^ " -inline " ^ inline; | _ -> () end;  let package = check_package_list package in let compiler, linker = if prof then ("ocamlcp", [|"-p"; "a"|]), ("ocamlcp", [|"-p"; "a"|]) else begin let ocaml_c_opt = if compilation = Native then (match ocamlopt with Some x -> x | _ -> failwith "ocamlopt was not found") else ocamlc in let use_findlib = package <> "" in if use_findlib then let thread = if thread then "-thread" else if vmthread then "-vmthread" else "" in let ocaml_c_opt = try Filename.chop_extension ocaml_c_opt with Invalid_argument _ -> ocaml_c_opt in let ocamlfind = sprintf "ocamlfind %s -package %s %s" ocaml_c_opt package thread in let compiler_args = crono4 ~label:"Oebuild, get_effective_command(compiler)" get_effective_command ocamlfind in let linker_args = if compile_only then "", [||] else let linkpkg = outkind <@ [Executable] in let cmd = if linkpkg then ocamlfind ^ " -linkpkg" else ocamlfind in split_prog_args cmd  in compiler_args, linker_args else split_prog_args ocaml_c_opt, split_prog_args ocaml_c_opt end in let times = Table.read () in let build_exit =  let deps, deps_ml, compilation_exit = if serial then let deps_ml = List.map replace_extension_to_ml deps in deps, deps_ml, serial_compile ~compilation ~times ~compiler ~cflags:!cflags ~includes:!includes ~toplevel_modules ~deps:deps_ml ~verbose else parallel_compile ~compilation ~times ?pp ~compiler ~cflags:!cflags ~includes:!includes ~toplevel_modules ~verbose ~jobs () in if verbose >= 4 then Printf.printf "SORTED DEPENDENCIES:\n[%s]\n\n%!" (String.concat "; " deps);  if compilation_exit = 0 then begin let opt = compilation = Native in let find_objs filenames = let objs = List.filter (fun x -> x ^^^ ".cmx") filenames in if opt then objs else List.map (fun x -> (Filename.chop_extension x) ^ ".cmo") objs in let mods = split_space other_mods in let mods = if compilation = Native then List.map (sprintf "%s.cmx") mods else List.map (sprintf "%s.cmo") mods in let obj_deps = if dontlinkdep then find_objs (List.map (fun ml -> if ml ^^^ ".ml" then (Filename.chop_extension ml) ^ ".cmx" else if ml ^^^ ".mli" then (Filename.chop_extension ml) ^ ".cmi" else ml) toplevel_modules) else mods @ (find_objs deps) in if compile_only then compilation_exit else begin let compiler_output = Buffer.create 100 in let link_exit = crono ~label:"Linking phase" (link ~compilation ~compiler:linker ~outkind ~lflags:!lflags ~includes:!includes ~libs ~deps:obj_deps ~outname ~verbose) () in if Buffer.length compiler_output > 0 then eprintf "%s\n%!" (Buffer.contents compiler_output); link_exit end end else compilation_exit in Table.write times; if build_exit = 0 && not compile_only then begin if verbose >= 1 then begin Printf.printf "\n%s %s\n%!" (string_of_compilation_type compilation) (string_of_output_type outkind); let result = [((Sys.getcwd()) // outname), (format_int (Unix.stat outname).Unix.st_size)] @ match compilation with | Native when outkind = Library -> List.flatten (List.map begin fun ext -> let filename = (Sys.getcwd()) // ((Filename.chop_extension outname) ^ ext) in if Sys.file_exists filename then [filename, (format_int (Unix.stat filename).Unix.st_size)] else [] end [".lib"; ".a"]) | Bytecode | Unspecified | Native -> [] in List.iter (Printf.printf "%s\n%!") (dot_leaders ~right_align:true ~postfix:" bytes" result); end; Built_successfully end else (Build_failed build_exit) ;;  let obj_extensions = [".cmi"; ".cmo"; ".cmx"; ".o"; ".obj"; ".annot"; ".cmt"; ".cmti"] let lib_extensions = [".cma"; ".cmxa"; ".lib"; ".a"; ".dll"] let clean ~deps () = let files = List.map begin fun name -> let name = Filename.chop_extension name in List.map ((^) name) obj_extensions end deps in let files = List.flatten files in let files = remove_dupl files in List.iter (remove_file ~verbose:false) files ;;  let distclean () = let cwd = Sys.getcwd() in let exists_suffix sufs name = List.exists (fun suf -> name ^^^ suf) sufs in let rec clean_dir dir = if not ((Unix.lstat dir).Unix.st_kind = Unix.S_LNK) then begin let files = Sys.readdir dir in let files = Array.to_list files in let files = List.map (fun x -> dir // x) files in let directories, files = List.partition Sys.is_directory files in let files = List.filter (exists_suffix (obj_extensions @ lib_extensions)) files in List.iter (remove_file ~verbose:false) files; let oebuild_times_filename = dir // Table.oebuild_times_filename in remove_file ~verbose:false oebuild_times_filename; List.iter clean_dir directories; end in clean_dir cwd; ;; let re_fl_pkg_exist = Str.regexp "\\(HAVE_FL_PKG\\|FINDLIB\\)(\\([-A-Za-z0-9_., ]+\\))" let s_prop_body = "\\(\\([A-Za-z0-9_-]+\\)\\(=\\|<>\\|!=\\|:\\)\\(.*\\)\\)" let re_prop_body = Str.regexp s_prop_body let re_env = Str.regexp ("ENV(" ^ s_prop_body ^ ")") let re_ocfg = Str.regexp ("OCAML(" ^ s_prop_body ^ ")") let re_comma = Str.regexp " *, *" let check_prop expr get =  try let name = String.trim (Str.matched_group 2 expr) in let op, is_eq = try let gr = Str.matched_group 3 expr in if gr = "=" || gr = ":" then Some (=), true else Some (<>), false with Not_found -> None, false in begin match op with | Some op -> let value = try String.trim (Str.matched_group 4 expr) with Not_found -> "" in (try op (get name) value           with Not_found                            -> not is_eq)           | None -> (try get name |> ignore; true with Not_found -> false)           end; with Not_found                            -> false            let check_restrictions restr = List.for_all begin function | "IS_UNIX" -> Sys.os_type = "Unix" | "IS_WIN32" -> Sys.os_type = "Win32" | "IS_CYGWIN" -> Sys.os_type = "Cygwin" | "HAVE_NATIVE" | "HAS_NATIVE" | "NATIVE" -> Ocaml_config.can_compile_native () <> None                        | res when Str.string_match re_env res 0 -> check_prop res Sys.getenv | res when Str.string_match re_ocfg res 0 -> check_prop res Ocaml_config.get | res when Str.string_match re_fl_pkg_exist res 0 -> let packages = Str.matched_group 2 res in let packages = Str.split re_comma packages in let redirect_stderr = if Sys.os_type = "Win32" then " 1>NUL 2>NUL" else " 1>/dev/null 2>/dev/null" in packages = [] || List.for_all begin fun package -> kprintf (Oebuild_util.command ~echo:false) "ocamlfind query %s %s" package redirect_stderr = 0 end packages | _ -> false end restr;; end
module Build_script_util = struct open Arg open Printf open Oebuild open Oebuild_util open Task type target = { descr : string; num : int; id : int; output_name : string; target_type : Oebuild.output_type; compilation_bytecode : bool; compilation_native : bool; toplevel_modules : string; mutable package : string; search_path : string; required_libraries : string; compiler_flags : string; linker_flags : string; thread : bool; vmthread : bool; pp : string; inline : int option; nodep : bool; dontlinkdep : bool; dontaddopt : bool; library_install_dir : string; other_objects : string; external_tasks : int list; restrictions : string list; dependencies : int list; show : bool; rc_filename : string option; } type target_map_entry = int * (string * target) exception Error let pushd, popd = let stack = Stack.create () in begin fun dir -> let cwd = Sys.getcwd () in Stack.push cwd stack; Sys.chdir dir end, (fun () -> Sys.chdir (Stack.pop stack));; let rpad txt c width = let result = txt ^ (String.make width c) in String.sub result 0 width;; let get_compilation_types native t = (if t.compilation_bytecode then [Bytecode] else []) @ (if t.compilation_native && native then [Native] else []) let string_of_compilation_type native t = let compilation = get_compilation_types native t in String.concat "/" (List.map string_of_compilation_type compilation) let create_target ?dir f x = (match dir with Some dir -> pushd dir | _ -> ()); f x; (match dir with Some _ -> popd() | _ -> ());; let create_target_func ?tg targets = match targets with | default_target :: _ -> (match tg with Some f -> create_target f | _ -> create_target default_target) | [] -> fun _ -> ();;  let ccomp_type = Ocaml_config.can_compile_native () let system_config () = let ocaml_version = match Shell.get_command_output "ocamlc -v" with x :: _ -> x | _ -> "" in let std_lib = match Shell.get_command_output "ocamlc -where" with x :: _ -> x | _ -> "" in let properties = [ "OCaml", ocaml_version; "Standard library directory", std_lib; "OCAMLLIB", (try Sys.getenv "OCAMLLIB" with Not_found -> "<Not_found>"); "Native compilation supported", (match ccomp_type with Some ccomp_type -> ccomp_type | _ -> "No"); ] in let buf = Buffer.create 100 in Buffer.add_string buf "\nSystem configuration\n"; let maxlength = List.fold_left (fun cand (x, _) -> let len = String.length x in max cand len) 0 properties in List.iter (fun (n, v) -> bprintf buf "  %s : %s\n" (rpad (n ^ " ") '.' maxlength) v) properties; Buffer.contents buf;;  module Option = struct let prefix = ref "" let change_dir = ref "src" let verbosity = ref 2 end  module ETask = struct let filter tasks phase = List.filter begin fun task -> if task.et_always_run_in_script then match task.et_phase with | Some ph -> ph = phase | _ -> false else false end tasks;; let execute = Task.handle begin fun ~env ~dir ~prog ~args -> let exit_code = Spawn.sync ~process_in:Spawn.redirect_to_stdout ~process_err:Spawn.redirect_to_stderr ~working_directory:dir ~env prog (Array.of_list args)  in match exit_code with | None -> () | Some _ -> raise Error end end  let targets_selected : target_map_entry list ref = ref [] let add_target targets name = try begin try let num = int_of_string name in if num <= 0 then (raise Exit); let name_tg = try List.find (fun (_, tg) -> tg.num = num) targets with Not_found -> raise Exit in targets_selected := (num, name_tg) :: !targets_selected; with _ -> let tg = List.assoc name targets in if tg.num <= 0 then (raise Exit); targets_selected := (tg.num, (name, tg)) :: !targets_selected; end with Exit | Not_found -> (raise (Arg.Bad (sprintf "Invalid target `%s'" name)));;  let rec find_target_dependencies targets trg = remove_dupl (List.flatten (List.map begin fun id -> try let _, target = List.find (fun (_, tg) -> tg.id = id) targets in (find_target_dependencies targets target) @ [target] with Not_found -> [] end trg.dependencies));;  let show = fun targets -> function num, (name, t) ->   let b_deps = find_target_dependencies targets t in let b_deps = List.map begin fun tg -> let name, _ = List.find (fun (_, t) -> t.id = tg.id) targets in name end b_deps in let compilation = (if t.compilation_bytecode then [Bytecode] else []) @ (if t.compilation_native && ccomp_type <> None then [Native] else []) in let outname = List.map begin fun compilation -> get_output_name ~compilation ~outkind:t.target_type ~outname:t.output_name ~dontaddopt:t.dontaddopt () end compilation in let outkind = string_of_output_type t.target_type in let compilation = string_of_compilation_type (ccomp_type <> None) t in let prop_1 = [ "Restrictions", (String.concat " " t.restrictions); "Output name", (String.concat ", " outname); ] in let prop_2 = [ "Findlib packages", t.package; "Search path", t.search_path; "Required libraries", t.required_libraries; "Compiler flags", t.compiler_flags; "Linker flags", t.linker_flags; "Toplevel modules", t.toplevel_modules; "Target dependencies", (String.concat ", " b_deps); ] in let properties = if t.target_type = Library then prop_1 @ [ "Install directory", (Oebuild.ocamllib // t.library_install_dir) ] @ prop_2 else prop_1 @ prop_2 in printf "%2d) %s (%s, %s)%s\n\n%!" num name outkind compilation (if t.descr <> "" then "\n    " ^ t.descr else ""); let maxlength = List.fold_left (fun cand (x, _) -> let len = String.length x in max cand len) 0 properties in List.iter (fun (n, v) -> printf "    %s : %s\n" (rpad (n ^ " ") '.' maxlength) v) properties;;  let install_lib ~compilation ~outname ~external_tasks ~deps target = match target.target_type with | Library -> let deps = deps() in Oebuild.install ~compilation ~outkind:target.target_type ~outname ~deps ~path:target.library_install_dir ~ccomp_type | Executable | Plugin | Pack | External -> eprintf "\"install\" not implemented for Executable, Plugin, Pack or External."; raise Exit;;  let rec execute_target ~external_tasks ~targets:avail_targets ~command ?target_deps target = if Oebuild.check_restrictions target.restrictions then begin let compilation = (if target.compilation_bytecode then [Bytecode] else []) @ (if target.compilation_native && (ccomp_type <> None) then [Native] else []) in let files = Str.split (Str.regexp " +") target.toplevel_modules in let deps () = let verbose = !Option.verbosity >= 4 in Oebuild_dep.ocamldep_toplevels ~verbose ~pp:target.pp ~ignore_stderr:false files |> Oebuild_dep.sort_dependencies in let etasks = List.map begin fun index -> let mktask = try List.assoc index external_tasks with Not_found -> assert false in mktask command end target.external_tasks in try match target.target_type with | External when command = `Build -> build ~targets:avail_targets ~external_tasks ~etasks ~deps ~compilation:Unspecified ~outname:target.output_name ~files ?target_deps ~verbose:!Option.verbosity target | External -> () | Executable | Library | Pack | Plugin -> List.iter begin fun compilation -> let outname = get_output_name ~compilation ~outkind:target.target_type ~outname:target.output_name ~dontaddopt:target.dontaddopt () in match command with | `Build -> build ~targets:avail_targets ~external_tasks ~etasks ~deps ~compilation ~outname ~files ?target_deps ~verbose:!Option.verbosity target | `Install_lib -> install_lib ~compilation ~outname ~external_tasks ~deps target | `Clean -> List.iter ETask.execute (ETask.filter etasks Before_clean); let deps = deps() in Oebuild.clean ~deps (); List.iter ETask.execute (ETask.filter etasks After_clean); | `Distclean -> if files <> [] then (Oebuild_util.remove_file ~verbose:false outname); | `Show | `Install | `Uninstall -> assert false end compilation with Exit -> () end else begin let target_name, _ = try List.find (fun (_, t) -> t.id = target.id) avail_targets with Not_found -> kprintf failwith "Target not found (id=%d)" target.id in if !Option.verbosity >= 1 then begin Printf.printf "=== %s ===\n%!" target_name; Printf.printf "Skipped: %s failed\n\n%!" (String.concat " AND " target.restrictions); end end  and build ~targets:avail_targets ~external_tasks ~etasks ~deps ~compilation ~outname ~files ?target_deps ~verbose target = let target_deps = match target_deps with | None -> []                                                   | Some x -> x in List.iter (execute_target ~external_tasks ~targets:avail_targets ~command:`Build) target_deps; let target_name, _ = try List.find (fun (_, t) -> t.id = target.id) avail_targets with Not_found -> kprintf failwith "Target not found (id=%d)" target.id in if !Option.verbosity >= 1 then Printf.printf "=== %s ===\n%!" target_name; List.iter ETask.execute (ETask.filter etasks Before_compile); let deps = if target.nodep then files else deps() in let tasks_compile = ETask.filter etasks Compile in if tasks_compile <> [] then List.iter ETask.execute (tasks_compile) else let crono = if !Option.verbosity >= 3 then Oebuild_util.crono else fun ?label f x -> f x in let libs = match target.rc_filename with | Some rc_filename -> let exit_code = Sys.command "where rc 2>&1 1>NUL" in if exit_code <> 0 then target.required_libraries else let exit_code = Sys.command "where cvtres 2>&1 1>NUL" in if exit_code <> 0 then target.required_libraries else (Filename.basename (Filename.chop_extension rc_filename)) ^ ".obj " ^ target.required_libraries | _ -> target.required_libraries in match crono ~label:"Build time" (Oebuild.build ~compilation ~package:target.package ~includes:target.search_path ~libs ~other_mods:target.other_objects ~outkind:target.target_type ~compile_only:false ~thread:target.thread ~vmthread:target.vmthread ~annot:false ~bin_annot:false ~pp:target.pp ?inline:target.inline ~cflags:target.compiler_flags ~lflags:target.linker_flags ~outname ~deps ~dontlinkdep:target.dontlinkdep ~dontaddopt:target.dontaddopt ~verbose ~toplevel_modules:files) () with | Built_successfully -> List.iter ETask.execute (ETask.filter etasks After_compile); | Build_failed n -> popd(); exit n ;;  let main ~cmd_line_args ~external_tasks ~general_commands ~targets:avail_targets = let module Command = struct type t = Build_script_command.t let find_args tag = try List.assoc tag cmd_line_args with Not_found -> [] let command tag = try let descr = snd (List.assoc tag general_commands) in [tag, (find_args tag), descr, ""] with Not_found -> [];; let command_install = command `Install let command_uninstall = command `Uninstall let string_of_command = function | `Install as c when command_install <> [] -> Build_script_command.string_of_command c | `Uninstall as c when command_uninstall <> [] -> Build_script_command.string_of_command c | `Install | `Uninstall -> assert false | x -> Build_script_command.string_of_command x;; let command_of_string = function | "install" when command_install <> [] -> `Install | "uninstall" when command_uninstall <> [] -> `Uninstall | ("install" | "uninstall") as c -> raise (Build_script_command.Unrecognized_command c) | x -> Build_script_command.command_of_string x;; let options = List.map (fun (a, b, c, d) -> a, Arg.align b, c, d) ([ `Build,       (find_args `Build), "Build libraries and executables (default command)", ""; ] @ command_install @ command_uninstall @ [ `Clean,       (find_args `Clean), "Remove output files for the selected target",       ""; `Distclean,   (find_args `Distclean), "Remove all build output",                           ""; `Install_lib, (find_args `Install_lib), "Install libraries as subdirectories relative\n               to the standard library directory", ""; `Show,        (find_args `Show), "Show the build options of a target",                ""; ]);; let anon_fun = function | `Show -> add_target avail_targets | `Build -> add_target avail_targets | `Install_lib -> add_target avail_targets | `Clean -> add_target avail_targets | (`Install | `Uninstall | `Distclean) as x -> fun arg -> kprintf failwith "Invalid anonymous argument `%s' for command `%s'" arg (string_of_command x);;  let execute command = pushd !Option.change_dir; let targets = List.rev !targets_selected in try begin let execute_general_command command = try let index, descr = List.assoc command general_commands in let task = List.assoc index external_tasks in ETask.execute (task command) with Not_found -> () in match command with | `Distclean -> List.iter (fun (_, t) -> execute_target ~external_tasks ~targets:avail_targets ~command t) avail_targets; Oebuild.distclean(); execute_general_command `Distclean; | (`Install | `Uninstall) as command -> execute_general_command command; | `Show -> printf "%s\n%!" (system_config ()); Printf.printf "\n%!" ; if targets = [] then (raise (Arg.Bad "show: no target specified")); List.iter begin fun t -> show avail_targets t; print_newline(); print_newline(); end targets; | _ -> if targets = [] then (raise (Arg.Bad (sprintf "%s: no target specified" (string_of_command command)))); List.iter begin fun (_, (name, tg)) -> let target_deps = remove_dupl (find_target_dependencies avail_targets tg) in  execute_target ~external_tasks ~targets:avail_targets ~command ~target_deps tg end targets end; popd(); with Arg.Bad _ as ex -> popd(); raise ex | ex -> popd(); Printf.eprintf "File \"build_script_util.ml\": %s\n%s\n%!" (Printexc.to_string ex) (Printexc.get_backtrace());; end in let module Argc = Argc.Make (Command) in let global_options = [ ("-C",       Set_string Option.change_dir, "<dir> Change directory before running [default: src]"); ("-verbose", Set_int Option.verbosity, " Verbosity level (0..5)"); ] in let global_options = Arg.align global_options in let command_name = Filename.basename Sys.argv.(0) in  let maxlength = List.fold_left (fun cand (x, _) -> let len = String.length x in max cand len) 0 avail_targets in let targets_shown = List.filter (fun (_, tg) -> tg.show) avail_targets in let help_of_targets = String.concat "\n" (List.map begin fun (name, tg) -> let name = rpad name ' ' maxlength in sprintf "  %2d) %s (%s, %s)%s" tg.num name (string_of_output_type tg.target_type) (string_of_compilation_type (ccomp_type <> None) tg) 	(if tg.descr <> "" then "\n      " ^ tg.descr else "") end targets_shown) in let usage_msg = sprintf "\nUSAGE\n  ocaml %s [global-options*] <command> [command-options*] [targets*]\n  ocaml %s <command> -help" command_name command_name in let help_string () = sprintf "%s\n\nGLOBAL OPTIONS%s\nCOMMANDS%s\n\nTARGETS\n%s" usage_msg (Arg.usage_string global_options "") Argc.help_of_commands help_of_targets in try Argc.parse ~usage_msg ~global_options ~default_command:`Build Command.execute with | Arg.Help _ -> print_endline (help_string ()) | Arg.Bad msg -> prerr_endline msg | Argc.Help_Command (cmd, (specs, descr, usage), msg) -> let name = Command.string_of_command cmd in begin match cmd with | `Distclean -> printf "%s %s - %s\n\nUSAGE\n  ocaml %s [global_options*] %s\n\nOPTIONS%s" command_name name descr command_name name (Arg.usage_string specs "") | _ -> printf "%s %s - %s\n\nUSAGE\n  ocaml %s [global_options*] %s [options*] [targets*]\n\nOPTIONS%s" command_name name descr command_name name (Arg.usage_string specs "") end; | Build_script_command.Unrecognized_command msg -> prerr_endline msg | Error -> exit 2 | ex -> prerr_endline (Printexc.to_string ex) ;; end

open Oebuild
open Build_script_util
open Arg
open Task
open Printf

let arg_0_record_backtrace = ref (Some true)
let arg_1_use_modified_gtkThread = ref (Some false)
let arg_2_prefix = ref None
let arg_3_gmisclib = ref (Some false)
let arg_4_nsis = ref (Some false)
let arg_5_prefix = ref None
let arg_6_ver_1_8_0 = ref (Some false)

let cmd_line_args = [
  `Uninstall, [
    "-prefix", String (fun x -> arg_5_prefix := Some x),
      (" Uninstallation prefix [default: see \"ocaml tools/uninstall.ml -help\"]");
    "-ver-1.8.0", Bool (fun x -> arg_6_ver_1_8_0 := Some x),
      (" Uninstall OCamlEditor ver. 1.8.0 or earlier [default: " ^ (match !arg_6_ver_1_8_0 with Some x -> sprintf "%s" (if x then "Set" else "Not Set") | _ -> failwith "build_script_printer (flag)") ^ "]");
  ];
  `Install, [
    "-prefix", String (fun x -> arg_2_prefix := Some x),
      (" Installation prefix [default: see \"ocaml tools/install.ml -help\"]");
    "-gmisclib", Bool (fun x -> arg_3_gmisclib := Some x),
      (" Install the gmisclib library (miscellaneous widgets \n             based on LablGtk2) [default: " ^ (match !arg_3_gmisclib with Some x -> sprintf "%s" (if x then "Set" else "Not Set") | _ -> failwith "build_script_printer (flag)") ^ "]");
    "-nsis", Bool (fun x -> arg_4_nsis := Some x),
      (" Create a Win32 installer with NSIS [default: " ^ (match !arg_4_nsis with Some x -> sprintf "%s" (if x then "Set" else "Not Set") | _ -> failwith "build_script_printer (flag)") ^ "]");
  ];
  `Build, [
    "-record-backtrace", Bool (fun x -> arg_0_record_backtrace := Some x),
      (" Turn recording of exception backtraces on or off [default: " ^ (match !arg_0_record_backtrace with Some x -> string_of_bool x | _ ->  failwith "build_script_printer (bool)") ^ "]");
    "-use-modified-gtkThread", Bool (fun x -> arg_1_use_modified_gtkThread := Some x),
      (" Set this flag if you have Lablgtk-2.14.2 or earlier\n                           and you want to use the included modified version of \n                           gtkThread.ml to reduce CPU consumption [default: " ^ (match !arg_1_use_modified_gtkThread with Some x -> sprintf "%s" (if x then "Set" else "Not Set") | _ -> failwith "build_script_printer (flag)") ^ "]");
  ];
]

let external_tasks = [
  
  0, (fun command -> {
    et_name                  = "comp_process_termination";
    et_env                   = [];
    et_env_replace           = false;
    et_dir                   = "..";
    et_cmd                   = "ocaml";
    et_args                  = [true,"tools/comp_process_termination.ml"];
    et_phase                 = Some Before_compile;
    et_always_run_in_project = true;
    et_always_run_in_script  = true;
    et_readonly              = false;
    et_visible               = true;
  });
  
  1, (fun command -> {
    et_name                  = "mkicons";
    et_env                   = [];
    et_env_replace           = false;
    et_dir                   = "..";
    et_cmd                   = "ocaml";
    et_args                  = [true,"tools/mkicons.ml"];
    et_phase                 = Some Before_compile;
    et_always_run_in_project = true;
    et_always_run_in_script  = true;
    et_readonly              = false;
    et_visible               = true;
  });
  
  2, (fun command -> {
    et_name                  = "RC_COMPILE";
    et_env                   = [];
    et_env_replace           = false;
    et_dir                   = "";
    et_cmd                   = "ocaml";
    et_args                  = [true,"../tools/rc_compile.ml"; true,"\"ocamleditor-msvc\""];
    et_phase                 = Some Before_compile;
    et_always_run_in_project = true;
    et_always_run_in_script  = true;
    et_readonly              = true;
    et_visible               = false;
  });
  
  3, (fun command -> {
    et_name                  = "prepare-build";
    et_env                   = [];
    et_env_replace           = false;
    et_dir                   = "..";
    et_cmd                   = "ocaml";
    et_args                  = [true,"tools/prepare_build.ml"];
    et_phase                 = Some Compile;
    et_always_run_in_project = true;
    et_always_run_in_script  = true;
    et_readonly              = false;
    et_visible               = true;
  });
  
  4, (fun command -> {
    et_name                  = "RC_COMPILE";
    et_env                   = [];
    et_env_replace           = false;
    et_dir                   = "";
    et_cmd                   = "ocaml";
    et_args                  = [true,"../tools/rc_compile.ml"; true,"\"launcher\""];
    et_phase                 = Some Before_compile;
    et_always_run_in_project = true;
    et_always_run_in_script  = true;
    et_readonly              = true;
    et_visible               = false;
  });
  
  5, (fun command -> {
    et_name                  = "SUBSYSTEM:WINDOWS";
    et_env                   = [];
    et_env_replace           = false;
    et_dir                   = "";
    et_cmd                   = "ocaml";
    et_args                  = [true,"../tools/editbin.ml"; true,"ocamleditorw"];
    et_phase                 = Some After_compile;
    et_always_run_in_project = true;
    et_always_run_in_script  = true;
    et_readonly              = true;
    et_visible               = false;
  });
  
  6, (fun command -> {
    et_name                  = "mkrelease";
    et_env                   = [];
    et_env_replace           = false;
    et_dir                   = "..";
    et_cmd                   = "ocaml";
    et_args                  = [true,"tools/mkrelease.ml"];
    et_phase                 = Some Before_clean;
    et_always_run_in_project = false;
    et_always_run_in_script  = false;
    et_readonly              = false;
    et_visible               = true;
  });
  
  7, (fun command -> {
    et_name                  = "mkversion";
    et_env                   = [];
    et_env_replace           = false;
    et_dir                   = "../tools";
    et_cmd                   = "ocaml";
    et_args                  = [true,"mkversion.ml"; true,"1.13.4"];
    et_phase                 = Some Before_clean;
    et_always_run_in_project = false;
    et_always_run_in_script  = false;
    et_readonly              = false;
    et_visible               = true;
  });
  
  8, (fun command -> {
    et_name                  = "generate_oebuild_script";
    et_env                   = [];
    et_env_replace           = false;
    et_dir                   = "..";
    et_cmd                   = "ocaml";
    et_args                  = [true,"tools/prepare_build.ml"; true,"-generate-oebuild-script"];
    et_phase                 = Some Before_clean;
    et_always_run_in_project = false;
    et_always_run_in_script  = false;
    et_readonly              = false;
    et_visible               = true;
  });
  
  9, (fun command -> {
    et_name                  = "Install OCamlEditor";
    et_env                   = [];
    et_env_replace           = false;
    et_dir                   = "..";
    et_cmd                   = "ocaml";
    et_args                  = [true,"tools/install.ml"; 
                                command = `Install && (!arg_4_nsis = Some true), "-nsis"; 
                                command = `Install && (!arg_3_gmisclib = Some true), "-gmisclib"; 
                                command = `Install, (match !arg_2_prefix with Some x -> sprintf "-prefix %s" x | _ -> "")];
    et_phase                 = Some Before_clean;
    et_always_run_in_project = false;
    et_always_run_in_script  = false;
    et_readonly              = false;
    et_visible               = true;
  });
  
  10, (fun command -> {
    et_name                  = "Uninstall OCamlEditor";
    et_env                   = [];
    et_env_replace           = false;
    et_dir                   = "..";
    et_cmd                   = "ocaml";
    et_args                  = [true,"tools/uninstall.ml"; 
                                command = `Uninstall && (!arg_6_ver_1_8_0 = Some true), "-ver-1.8.0"; 
                                command = `Uninstall, (match !arg_5_prefix with Some x -> sprintf "-prefix %s" x | _ -> "")];
    et_phase                 = Some Before_clean;
    et_always_run_in_project = false;
    et_always_run_in_script  = false;
    et_readonly              = false;
    et_visible               = true;
  });
  
  11, (fun command -> {
    et_name                  = "distclean";
    et_env                   = [];
    et_env_replace           = false;
    et_dir                   = "..";
    et_cmd                   = "ocaml";
    et_args                  = [true,"tools/distclean.ml"];
    et_phase                 = Some Before_clean;
    et_always_run_in_project = false;
    et_always_run_in_script  = false;
    et_readonly              = false;
    et_visible               = true;
  });
  
  12, (fun command -> {
    et_name                  = "install";
    et_env                   = [];
    et_env_replace           = false;
    et_dir                   = "..";
    et_cmd                   = "ocaml";
    et_args                  = [true,"tools/findlib.ml"; true,"install"];
    et_phase                 = None;
    et_always_run_in_project = false;
    et_always_run_in_script  = false;
    et_readonly              = true;
    et_visible               = true;
  });
  
  13, (fun command -> {
    et_name                  = "uninstall";
    et_env                   = [];
    et_env_replace           = false;
    et_dir                   = "..";
    et_cmd                   = "ocaml";
    et_args                  = [true,"tools/findlib.ml"; true,"uninstall"];
    et_phase                 = None;
    et_always_run_in_project = false;
    et_always_run_in_script  = false;
    et_readonly              = true;
    et_visible               = true;
  });
  
  14, (fun command -> {
    et_name                  = "reinstall";
    et_env                   = [];
    et_env_replace           = false;
    et_dir                   = "..";
    et_cmd                   = "ocaml";
    et_args                  = [true,"tools/findlib.ml"; true,"reinstall"];
    et_phase                 = None;
    et_always_run_in_project = false;
    et_always_run_in_script  = false;
    et_readonly              = true;
    et_visible               = true;
  });
  
  15, (fun command -> {
    et_name                  = "print";
    et_env                   = [];
    et_env_replace           = false;
    et_dir                   = "..";
    et_cmd                   = "ocaml";
    et_args                  = [true,"tools/findlib.ml"; true,"print"];
    et_phase                 = None;
    et_always_run_in_project = false;
    et_always_run_in_script  = false;
    et_readonly              = true;
    et_visible               = true;
  });
];;


let general_commands = [
  `Distclean, (11, "distclean");
  `Install, (9, "Install OCamlEditor");
  `Uninstall, (10, "Uninstall OCamlEditor");
]


(* Targets ==================================================== *)

let targets = [
  
  (* 0 *)
  "common", {
    descr                = "";
    num                  = 0;
    id                   = 4;
    output_name          = "common/common";
    target_type          = Library;
    compilation_bytecode = true;
    compilation_native   = true;
    toplevel_modules     = "common/common.ml";
    package              = "";
    search_path          = "common"; (* -I *)
    required_libraries   = "";
    compiler_flags       = "-g";
    linker_flags         = "-g";
    thread               = true;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = false;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [0];
    restrictions         = [];
    dependencies         = [];
    show                 = false;
    rc_filename          = None;
  };
  
  (* 0 *)
  "icons", {
    descr                = "";
    num                  = 0;
    id                   = 10;
    output_name          = "icons/icons";
    target_type          = Library;
    compilation_bytecode = true;
    compilation_native   = true;
    toplevel_modules     = "icons/icons.ml";
    package              = "lablgtk2";
    search_path          = "common"; (* -I *)
    required_libraries   = "";
    compiler_flags       = "-g";
    linker_flags         = "-g";
    thread               = false;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = false;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [1];
    restrictions         = [];
    dependencies         = [];
    show                 = false;
    rc_filename          = None;
  };
  
  (* 0 *)
  "oebuildlib", {
    descr                = "";
    num                  = 0;
    id                   = 7;
    output_name          = "oebuildlib";
    target_type          = Library;
    compilation_bytecode = true;
    compilation_native   = true;
    toplevel_modules     = "oebuild/oebuild.ml oebuild/oebuild_dep_ext.ml";
    package              = "";
    search_path          = "common oebuild"; (* -I *)
    required_libraries   = "";
    compiler_flags       = "-w y";
    linker_flags         = "";
    thread               = true;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = false;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [];
    restrictions         = [];
    dependencies         = [4];
    show                 = false;
    rc_filename          = None;
  };
  
  (* 1 *)
  "oebuild", {
    descr                = "";
    num                  = 1;
    id                   = 5;
    output_name          = "oebuild/oebuild";
    target_type          = Executable;
    compilation_bytecode = true;
    compilation_native   = true;
    toplevel_modules     = "oebuild/oebuild_tool.ml";
    package              = "str,unix";
    search_path          = "common oebuild"; (* -I *)
    required_libraries   = "common";
    compiler_flags       = "-w y";
    linker_flags         = "";
    thread               = true;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = false;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [];
    restrictions         = [];
    dependencies         = [7];
    show                 = true;
    rc_filename          = None;
  };
  
  (* 2 *)
  "gmisclib", {
    descr                = "Miscellaneous widgets based on LablGtk2.";
    num                  = 2;
    id                   = 8;
    output_name          = "gmisclib";
    target_type          = Library;
    compilation_bytecode = true;
    compilation_native   = true;
    toplevel_modules     = "gmisclib/gmisclib.ml";
    package              = "lablgtk2";
    search_path          = "gmisclib"; (* -I *)
    required_libraries   = "";
    compiler_flags       = "-g";
    linker_flags         = "-g";
    thread               = false;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = false;
    dontaddopt           = false;
    library_install_dir  = "gmisclib"; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [];
    restrictions         = [];
    dependencies         = [];
    show                 = true;
    rc_filename          = None;
  };
  
  (* 2 *)
  "otherwidgets", {
    descr                = "";
    num                  = 0;
    id                   = 9;
    output_name          = "otherwidgets";
    target_type          = Library;
    compilation_bytecode = true;
    compilation_native   = true;
    toplevel_modules     = "otherwidgets/otherwidgets.ml";
    package              = "lablgtk2";
    search_path          = "icons common otherwidgets gmisclib"; (* -I *)
    required_libraries   = "gmisclib";
    compiler_flags       = "-w sy -g";
    linker_flags         = "-w sy -g";
    thread               = false;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = false;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [];
    restrictions         = [];
    dependencies         = [8];
    show                 = false;
    rc_filename          = None;
  };
  
  (* 3 *)
  "ocamleditor", {
    descr                = "";
    num                  = 3;
    id                   = 12;
    output_name          = "ocamleditor";
    target_type          = Executable;
    compilation_bytecode = false;
    compilation_native   = true;
    toplevel_modules     = "ocamleditor.ml";
    package              = "compiler-libs.common,dynlink,lablgtk2,str,unix,xml-light";
    search_path          = "+ocamldoc gmisclib common icons otherwidgets oebuild "; (* -I *)
    required_libraries   = "process_termination odoc_info gmisclib common icons otherwidgets oebuildlib ocamleditor_lib";
    compiler_flags       = "-w syxm -g";
    linker_flags         = "-g";
    thread               = true;
    vmthread             = false;
    pp                   = "";
    inline               = Some 50;
    nodep                = true;
    dontlinkdep          = false;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [];
    restrictions         = [];
    dependencies         = [14; 19; 16; 26; 22];
    show                 = true;
    rc_filename          = None;
  };
  
  (* 4 *)
  "ocamleditor-bytecode", {
    descr                = "";
    num                  = 4;
    id                   = 0;
    output_name          = "ocamleditor";
    target_type          = Executable;
    compilation_bytecode = true;
    compilation_native   = false;
    toplevel_modules     = "ocamleditor.ml";
    package              = "compiler-libs.common,dynlink,lablgtk2,str,unix,xml-light";
    search_path          = "+ocamldoc gmisclib common icons otherwidgets oebuild "; (* -I *)
    required_libraries   = "process_termination odoc_info gmisclib common icons otherwidgets oebuildlib";
    compiler_flags       = "-w syxm -g";
    linker_flags         = "-g";
    thread               = true;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = false;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [];
    restrictions         = [];
    dependencies         = [4; 10; 7; 5; 6; 8; 9; 20; 17; 18; 25];
    show                 = true;
    rc_filename          = None;
  };
  
  (* 5 *)
  "ocamleditor-msvc", {
    descr                = "";
    num                  = 5;
    id                   = 15;
    output_name          = "ocamleditor";
    target_type          = Executable;
    compilation_bytecode = false;
    compilation_native   = true;
    toplevel_modules     = "ocamleditor.ml";
    package              = "compiler-libs.common,dynlink,lablgtk2,str,unix,xml-light";
    search_path          = "+ocamldoc gmisclib common icons otherwidgets oebuild "; (* -I *)
    required_libraries   = "process_termination odoc_info gmisclib common icons otherwidgets oebuildlib ocamleditor_lib";
    compiler_flags       = "-w syxm -g";
    linker_flags         = "-g";
    thread               = true;
    vmthread             = false;
    pp                   = "";
    inline               = Some 50;
    nodep                = true;
    dontlinkdep          = false;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [2];
    restrictions         = ["IS_WIN32"];
    dependencies         = [14; 19; 16; 26; 22];
    show                 = true;
    rc_filename          = Some ".\\ocamleditor.opt.resource.rc";
  };
  
  (* 6 *)
  "ocamleditor-native", {
    descr                = "";
    num                  = 6;
    id                   = 11;
    output_name          = "ocamleditor";
    target_type          = Executable;
    compilation_bytecode = false;
    compilation_native   = true;
    toplevel_modules     = "ocamleditor.ml";
    package              = "compiler-libs.common,dynlink,lablgtk2,str,unix,xml-light";
    search_path          = "+ocamldoc gmisclib common icons otherwidgets oebuild "; (* -I *)
    required_libraries   = "process_termination odoc_info gmisclib common icons otherwidgets oebuildlib ocamleditor_lib";
    compiler_flags       = "-w syxm -g";
    linker_flags         = "-g";
    thread               = true;
    vmthread             = false;
    pp                   = "";
    inline               = Some 50;
    nodep                = false;
    dontlinkdep          = false;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [];
    restrictions         = [];
    dependencies         = [14; 19; 16; 26];
    show                 = true;
    rc_filename          = None;
  };
  
  (* 7 *)
  "ocamleditor-lib", {
    descr                = "";
    num                  = 7;
    id                   = 14;
    output_name          = "ocamleditor_lib";
    target_type          = Library;
    compilation_bytecode = false;
    compilation_native   = true;
    toplevel_modules     = "ocamleditor_lib.ml";
    package              = "compiler-libs.common,dynlink,lablgtk2,str,unix,xml-light";
    search_path          = "+ocamldoc gmisclib common icons otherwidgets oebuild "; (* -I *)
    required_libraries   = "";
    compiler_flags       = "-w syxm -g";
    linker_flags         = "-g";
    thread               = true;
    vmthread             = false;
    pp                   = "";
    inline               = Some 50;
    nodep                = false;
    dontlinkdep          = false;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [];
    restrictions         = [];
    dependencies         = [4; 10; 5; 6; 8; 9; 20];
    show                 = true;
    rc_filename          = None;
  };
  
  (* 8 *)
  "plugin-remote-bytecode", {
    descr                = "";
    num                  = 8;
    id                   = 17;
    output_name          = "../plugins/remote";
    target_type          = Library;
    compilation_bytecode = true;
    compilation_native   = false;
    toplevel_modules     = "remote.ml";
    package              = "curl,lablgtk2";
    search_path          = "common icons otherwidgets gmisclib"; (* -I *)
    required_libraries   = "";
    compiler_flags       = "-g -w -10";
    linker_flags         = "-g curl.cma";
    thread               = false;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = true;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [];
    restrictions         = ["FINDLIB(curl)"];
    dependencies         = [];
    show                 = true;
    rc_filename          = None;
  };
  
  (* 9 *)
  "plugin-remote-native", {
    descr                = "";
    num                  = 9;
    id                   = 16;
    output_name          = "../plugins/remote";
    target_type          = Plugin;
    compilation_bytecode = false;
    compilation_native   = true;
    toplevel_modules     = "remote.ml";
    package              = "curl,lablgtk2";
    search_path          = "common icons otherwidgets gmisclib"; (* -I *)
    required_libraries   = "";
    compiler_flags       = "-g -w -10";
    linker_flags         = "-g curl.cmxa";
    thread               = false;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = true;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [];
    restrictions         = ["FINDLIB(curl)"];
    dependencies         = [];
    show                 = true;
    rc_filename          = None;
  };
  
  (* 10 *)
  "plugin-dotviewer-bytecode", {
    descr                = "";
    num                  = 10;
    id                   = 18;
    output_name          = "../plugins/dot_viewer_svg";
    target_type          = Library;
    compilation_bytecode = true;
    compilation_native   = false;
    toplevel_modules     = "dot_viewer_svg.ml";
    package              = "lablgtk2,xml-light";
    search_path          = "common gmisclib otherwidgets"; (* -I *)
    required_libraries   = "gmisclib";
    compiler_flags       = "-w syxm -g";
    linker_flags         = "-g lablrsvg.cma";
    thread               = true;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = true;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [];
    restrictions         = ["FINDLIB(lablgtk2.rsvg)"];
    dependencies         = [];
    show                 = true;
    rc_filename          = None;
  };
  
  (* 11 *)
  "plugin-dotviewer-native", {
    descr                = "";
    num                  = 11;
    id                   = 19;
    output_name          = "../plugins/dot_viewer_svg";
    target_type          = Plugin;
    compilation_bytecode = false;
    compilation_native   = true;
    toplevel_modules     = "dot_viewer_svg.ml";
    package              = "lablgtk2.rsvg";
    search_path          = "common gmisclib"; (* -I *)
    required_libraries   = "";
    compiler_flags       = "-g -w syxm";
    linker_flags         = "-g lablrsvg.cmxa";
    thread               = true;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = true;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [];
    restrictions         = ["FINDLIB(lablgtk2.rsvg)"];
    dependencies         = [];
    show                 = true;
    rc_filename          = None;
  };
  
  (* 12 *)
  "plugin-diff-bytecode", {
    descr                = "";
    num                  = 12;
    id                   = 25;
    output_name          = "../plugins/plugin_diff";
    target_type          = Library;
    compilation_bytecode = true;
    compilation_native   = false;
    toplevel_modules     = "plugin_diff_gtext.ml plugin_diff.ml";
    package              = "compiler-libs.common,diff,lablgtk2,str,unix,xml-light";
    search_path          = "common otherwidgets gmisclib oebuild +ocamldoc icons"; (* -I *)
    required_libraries   = "";
    compiler_flags       = "-g -w -26-10";
    linker_flags         = "-g odiff.cma";
    thread               = true;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = true;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [];
    restrictions         = ["FINDLIB(diff)"];
    dependencies         = [];
    show                 = true;
    rc_filename          = None;
  };
  
  (* 13 *)
  "plugin-diff-native", {
    descr                = "";
    num                  = 13;
    id                   = 26;
    output_name          = "../plugins/plugin_diff";
    target_type          = Plugin;
    compilation_bytecode = false;
    compilation_native   = true;
    toplevel_modules     = "plugin_diff_gtext.ml plugin_diff.ml ";
    package              = "compiler-libs,diff,lablgtk2,str,unix";
    search_path          = "common otherwidgets gmisclib oebuild icons"; (* -I *)
    required_libraries   = "";
    compiler_flags       = "-g -w -26-10";
    linker_flags         = "-g odiff.cmxa";
    thread               = true;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = true;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [];
    restrictions         = ["FINDLIB(diff)"];
    dependencies         = [];
    show                 = true;
    rc_filename          = None;
  };
  
  (* 13 *)
  "prepare-build", {
    descr                = "";
    num                  = 0;
    id                   = 20;
    output_name          = "";
    target_type          = External;
    compilation_bytecode = true;
    compilation_native   = false;
    toplevel_modules     = "";
    package              = "";
    search_path          = ""; (* -I *)
    required_libraries   = "";
    compiler_flags       = "";
    linker_flags         = "";
    thread               = false;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = false;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [3];
    restrictions         = [];
    dependencies         = [];
    show                 = false;
    rc_filename          = None;
  };
  
  (* 14 *)
  "launcher", {
    descr                = "Utility to open OCaml files from the file manager";
    num                  = 14;
    id                   = 22;
    output_name          = "ocamleditorw";
    target_type          = Executable;
    compilation_bytecode = false;
    compilation_native   = true;
    toplevel_modules     = "ocamleditor_launcher.ml";
    package              = "unix,str";
    search_path          = "common"; (* -I *)
    required_libraries   = "common";
    compiler_flags       = "-compact";
    linker_flags         = "-compact";
    thread               = false;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = false;
    dontaddopt           = true;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [4; 5];
    restrictions         = ["OCAML(system<>mingw)"];
    dependencies         = [];
    show                 = true;
    rc_filename          = Some ".\\ocamleditorw.resource.rc";
  };
  
  (* 14 *)
  "tools", {
    descr                = "";
    num                  = 0;
    id                   = 13;
    output_name          = "";
    target_type          = External;
    compilation_bytecode = true;
    compilation_native   = false;
    toplevel_modules     = "";
    package              = "";
    search_path          = ""; (* -I *)
    required_libraries   = "";
    compiler_flags       = "";
    linker_flags         = "";
    thread               = false;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = false;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [6; 7; 8; 9; 10; 11];
    restrictions         = [];
    dependencies         = [];
    show                 = false;
    rc_filename          = None;
  };
  
  (* 14 *)
  "FINDLIB-TOOLS", {
    descr                = "";
    num                  = 0;
    id                   = 27;
    output_name          = "";
    target_type          = External;
    compilation_bytecode = true;
    compilation_native   = false;
    toplevel_modules     = "";
    package              = "";
    search_path          = ""; (* -I *)
    required_libraries   = "";
    compiler_flags       = "";
    linker_flags         = "";
    thread               = false;
    vmthread             = false;
    pp                   = "";
    inline               = None;
    nodep                = false;
    dontlinkdep          = false;
    dontaddopt           = false;
    library_install_dir  = ""; (* Relative to the Standard Library Directory *)
    other_objects        = "";
    external_tasks       = [12; 13; 14; 15];
    restrictions         = [];
    dependencies         = [];
    show                 = false;
    rc_filename          = None;
  };
];;

(* End of Targets ============================================= *)

let _ = main ~cmd_line_args ~external_tasks ~general_commands ~targets
